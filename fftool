#!/usr/bin/env python
# fftool - generate force field parameters for molecular system
# Agilio Padua <agilio.padua@ens-lyon.fr>, version 2019/02/22
# http://perso.ens-lyon.fr/agilio.padua

# Copyright (C) 2013 Agilio Padua
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import argparse
import math
import random

# tolerances to deduce bonds and angles from input configuration
BondTol = 0.25                          # Angstrom
AngleTol = 15.0                         # degrees

kCal = 4.184                            # kJ
eV = 96.485                             # kJ/mol
fpe0 = 0.000719756                      # (4 Pi eps0) in e^2/(kJ/mol A)

# --------------------------------------

atomic_wt = {'H': 1.008, 'Li': 6.941, 'B': 10.811, 'C': 12.011,
             'N': 14.006, 'O': 15.999, 'F': 18.998, 'Ne': 20.180,
             'Na': 22.990, 'Mg': 24.305, 'Al': 26.982, 'Si':  28.086,
             'P': 30.974, 'S': 32.065, 'Cl': 35.453, 'Ar': 39.948,
             'K': 39.098, 'Ca': 40.078, 'Ti': 47.867, 'Fe': 55.845,
             'Zn': 65.38, 'Se': 78.971, 'Br': 79.904, 'Kr': 83.798,
             'Mo': 95.96, 'Ru': 101.07, 'Sn': 118.710, 'Te': 127.60,
             'I': 126.904, 'Xe': 131.293}

atomic_nr = {'H': 1, 'Li': 3, 'B': 5, 'C': 6, 'N': 7, 'O': 8, 'F': 9, 'Ne': 10,
             'Na': 11, 'Mg': 12, 'Al': 13, 'Si': 14, 'P': 15, 'S': 16,
             'Cl': 17, 'Ar': 18, 'K': 19, 'Ca': 20, 'Ti': 22, 'Fe': 26,
             'Zn': 30, 'Se': 34, 'Br': 35, 'Kr': 36, 'Mo': 42, 'Ru': 44,
             'Sn': 50, 'Te': 52, 'I': 53, 'Xe': 54}
    
def atomic_weight(name):
    if name[:2] in atomic_wt:
        return atomic_wt[name[:2]]
    elif name[0] in atomic_wt:
        return atomic_wt[name[0]]
    else:
        print('warning: unknown atomic weight for atom ' + name)
        return 0.0

def atomic_symbol(name):
    if name[:2] in atomic_wt:
        return name[:2]
    elif name[0] in atomic_wt:
        return name[0]
    else:
        print('warning: unknown symbol for atom ' + name)
        return name

def atomic_number(name):
    if name[:2] in atomic_nr:
        return atomic_nr[name[:2]]
    elif name[0] in atomic_nr:
        return atomic_nr[name[0]]
    else:
        print('warning: unknown atomic weight for atom ' + name)
        return 0

# --------------------------------------

class vector(object):
    """minimal 3-vector"""

    def __init__(self, x = 0.0, y = 0.0, z = 0.0):
        if isinstance(x, tuple) or isinstance(x, list):
            self.x, self.y, self.z = x
        else:
            self.x = x
            self.y = y
            self.z = z

    def __getitem__(self, index):
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        elif index == 2:
            return self.z
        else:
            raise IndexError('vector index out of range')

    def __abs__(self):
        return math.sqrt(self.x**2 + self.y**2 + self.z**2)
    
    def __add__(self, other):
        if isinstance(other, vector):
            return vector(self.x + other.x, self.y + other.y, self.z + other.z)
        else:
            raise TypeError('wrong type in vector addition')

    def __sub__(self, other):
        if isinstance(other, vector):
            return vector(self.x - other.x, self.y - other.y, self.z - other.z)
        else:
            raise TypeError('wrong type in vector subtraction')

    def __mul__(self, other): 
        if isinstance(other, vector): # dot product
            return self.x * other.x + self.y * other.y + self.z * other.z
        else:
            return vector(self.x * other, self.y * other, self.z * other)

    def __div__(self, other):
        return vector(self.x / other, self.y / other, self.z / other)

    def __neg__(self):
        return vector(-self.x, -self.y, -self.z)

    def __str__(self):
#        return '( ' + ', '.join([str(val) for val in\
#                                  (self.x, self.y, self.z)]) + ' )'
        return "( {0}, {1}, {2} )".format(self.x, self.y, self.z)

    def __repr__(self):
        return str(self) + ' instance at 0x' + str(hex(id(self))[2:].upper())

    def cross(self, other):
        return vector(self.y * other.z - self.z * other.y,  
                      self.z * other.x - self.x * other.z,  
                      self.x * other.y - self.y * other.x)

    def unit(self):
        a = abs(self)
        return vector(self.x / a, self.y / a, self.z / a)


# --------------------------------------
 
class atom(object):
    """atom in a molecule or in a force field"""

    def __init__(self, name, m = 0.0):
        self.name = name                  # atom type, in str
        self.type = name                  # equivalent atom type for bonded interactions, in str
        self.symbol = atomic_symbol(name)
        self.ityp = -1                    # atom type index for this atom starts from 0
        if m == 0.0:
            self.m = atomic_weight(self.name)
        else:
            self.m = m
        self.q = 0.0
        self.pot = ''                     # non-bonded potential function, like 'lj'
        self.par = []                     # non-bonded potential parameters, [epsilon, sigma]
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        self.drude = False
        self.md = 0
        self.qd_base = 0
        self.kd = 0
        self.alpha = 0   # /A^3
        self.thole = 2.6
        self.ityp_drude = -1              # atom type index for drude particle starts from 0
        self.ibtyp_drude = -1             # bond type index for drude bond starts from 0
    
    @property
    def qd(self):
        if self.drude:
            return self.qd_base * (fpe0 * self.kd * self.alpha)**0.5
        else:
            return 0

    def __str__(self):
        if hasattr(self, 'type'):
            return "atom {0:5s} {1:3s}  m = {2:7.3f}  q = {3:+7.4f}  "\
                   "{4} {5}".format(self.name, self.type, self.m, self.q,
                                  self.pot, str(self.par))
        else:
            return "atom {0:5s}  m = {1:7.3f}".format(self.name, self.m)

    def setpar(self, attp, q, pot, par):
        self.type = attp
        self.q = q
        self.pot = pot
        self.par = par


def dist2atoms(ati, atj, box = None):
    dx = atj.x - ati.x
    dy = atj.y - ati.y
    dz = atj.z - ati.z
    if isinstance(box, cell):
        if box.triclinic:
            ri = [ ati.x, ati.y, ati.z ]
            rj = [ atj.x, atj.y, atj.z ]
            fi = box.ctof(ri)
            fj = box.ctof(rj)
            fd = [ fj[0] - fi[0], fj[1] - fi[1], fj[2] - fi[2] ]
            if 'x' in box.pbc:
                fd[0] -= round(fd[0])
            if 'y' in box.pbc:
                fd[1] -= round(fd[1])
            if 'z' in box.pbc:
                fd[2] -= round(fd[2])
            dx, dy, dz = box.ftoc(fd)
        else:
            if 'x' in box.pbc:
                dx -= round(dx / box.lx) * box.lx
            if 'y' in box.pbc:
                dy -= round(dy / box.ly) * box.ly
            if 'z' in box.pbc:
                dz -= round(dz / box.lz) * box.lz
    return math.sqrt(dx*dx + dy*dy + dz*dz)


def angle3atoms(ati, atj, atk, box = None):
    djix = ati.x - atj.x
    djiy = ati.y - atj.y
    djiz = ati.z - atj.z    
    djkx = atk.x - atj.x
    djky = atk.y - atj.y
    djkz = atk.z - atj.z
    if isinstance(box, cell):
        if box.triclinic:
            ri = [ ati.x, ati.y, ati.z ]
            rj = [ atj.x, atj.y, atj.z ]
            rk = [ atk.x, atk.y, atk.z ]
            fi = box.ctof(ri)
            fj = box.ctof(rj)
            fk = box.ctof(rk)
            fdji = [ fi[0] - fj[0], fi[1] - fj[1], fi[2] - fj[2] ]
            fdjk = [ fk[0] - fj[0], fk[1] - fj[1], fk[2] - fj[2] ]
            if 'x' in box.pbc:
                fdji[0] -= round(fdji[0])
                fdjk[0] -= round(fdjk[0])
            if 'y' in box.pbc:
                fdji[1] -= round(fdji[1])
                fdjk[1] -= round(fdjk[1])
            if 'z' in box.pbc:
                fdji[2] -= round(fdji[2])
                fdjk[2] -= round(fdjk[2])
            djix, djiy, djiz = box.ftoc(fdji)
            djkx, djky, djkz = box.ftoc(fdjk)
        else:
            if 'x' in box.pbc:
                djix -= round(djix / box.lx) * box.lx
                djkx -= round(djkx / box.lx) * box.lx
            if 'y' in box.pbc:
                djiy -= round(djiy / box.ly) * box.ly
                djky -= round(djky / box.ly) * box.ly
            if 'z' in box.pbc:
                djiz -= round(djiz / box.lz) * box.lz
                djkz -= round(djkz / box.lz) * box.lz
    vji = vector(djix, djiy, djiz)
    vjk = vector(djkx, djky, djkz)
    return math.acos((vji * vjk) / (abs(vji) * abs(vjk))) * 180.0 / math.pi


class bond(object):
    """covalent bond in a molecule or in a force field"""

    def __init__(self, i = -1, j = -1, r = 0.0):
        self.i = i                   # index of first atom in molecule, starts from 0
        self.j = j
        self.r = r
        self.ityp = -1               # bond type index for this bond starts from 0

    def __str__(self):
        if hasattr(self, 'name'):
            if self.i != -1:
                return "bond {0:5d} {1:5d}  {2}  {3} {4}".format(self.i + 1,
                        self.j + 1, self.name, self.pot, str(self.par))
            else:
                return "bond {0}  {1} {2}".format(self.name, self.pot,
                                                  str(self.par))
        else:
            return "bond {0:5d} {1:5d}".format(self.i + 1, self.j + 1)

    def setpar(self, iatp, jatp, pot, par):
        self.name = '{0}-{1}'.format(iatp, jatp)
        self.iatp = iatp              # equivalent atom type, in str
        self.jatp = jatp
        self.pot = pot
        self.par = par

    def seteqval(self):
        if not hasattr(self, 'name'):
            print('  error: bond parameters not set')
            sys.exit(1)
        if self.pot == 'harm':
            self.eqval = self.par[0]
        elif self.pot == 'cons':
            self.eqval = self.par[0]
        else:
            print('  error: unkown bond potential ' + self.pot)
            sys.exit(1)

    def checkval(self, r):
        if not hasattr(self, 'eqval'):
            print('  error: bond equilibrium value not set')
            sys.exit(1)
        delta = abs(r - self.eqval)
        if delta < BondTol:
            return True
        else:
            return False


class angle(object):
    """valence angle"""

    def __init__(self, i = -1, j = -1, k = -1, theta = 0.0):
        self.i = i
        self.j = j
        self.k = k
        self.theta = theta
        self.ityp = -1

    def __str__(self):
        if hasattr(self, 'name'):
            if self.i != -1:
                return 'angle {0:5d} {1:5d} {2:5d}  {3}  {4} '\
                  '{5}'.format(self.i + 1, self.j + 1, self.k + 1,
                               self.name, self.pot, str(self.par))
            else:
                return "angle {0}  {1} {2}".format(self.name, self.pot,
                                                   str(self.par))
        else:
            return 'angle {0:5d} {1:5d} {2:5d}'.format(self.i + 1, self.j + 1,
                                                       self.k + 1)

    def setpar(self, iatp, jatp, katp, pot, par):
        self.name = '{0}-{1}-{2}'.format(iatp, jatp, katp)
        self.iatp = iatp
        self.jatp = jatp
        self.katp = katp
        self.pot = pot
        self.par = par

    def seteqval(self):
        if not hasattr(self, 'name'):
            print('  error: angle parameters not set')
            sys.exit(1)
        if self.pot == 'harm':
            self.eqval = self.par[0]
        elif self.pot == 'cons':
            self.eqval = self.par[0]
        else:
            print('  error: unkown angle potential ' + self.pot)
            sys.exit(1)

    def checkval(self, th):
        if not hasattr(self, 'eqval'):
            print('  error: angle equilibrium value not set')
            sys.exit(1)
        delta = abs(th - self.eqval)
        if delta < AngleTol:
            return True
        else:
            return False


class dihed(object):
    """dihedral angle (torsion)"""

    def __init__(self, i = -1, j = -1, k = -1, l = -1, phi = 0.0):
        self.i = i
        self.j = j
        self.k = k
        self.l = l
        self.phi = phi
        self.ityp = -1

    def __str__(self):
        if hasattr(self, 'name'):
            if self.i != -1:
                return "dihedral {0:5d} {1:5d} {2:5d} {3:5d}  {4}  {5} "\
                  "{6}".format(self.i + 1, self.j + 1, self.k + 1, self.l + 1,
                               self.name, self.pot, str(self.par))
            else:
                return "dihedral {0}  {1} {2}".format(self.name, self.pot,
                                                      str(self.par))
        else:
            return "dihedral {0:5d} {1:5d} {2:5d} {3:5d}".format(self.i + 1,
                    self.j + 1, self.k + 1, self.l + 1)

    def setpar(self, iatp, jatp, katp, latp, pot, par):
        self.name = '{0}-{1}-{2}-{3}'.format(iatp, jatp, katp, latp)
        self.iatp = iatp
        self.jatp = jatp
        self.katp = katp
        self.latp = latp
        self.pot = pot
        self.par = par


class dimpr(dihed):
    """dihedral angle (improper)"""
    
    def __str__(self):
        if hasattr(self, 'name'):
            if self.i != -1:
                return "improper {0:5d} {1:5d} {2:5d} {3:5d}  {4}  {5} "\
                  "{6}".format(self.i + 1, self.j + 1, self.k + 1, self.l + 1,
                               self.name, self.pot, str(self.par))
            else:
                return "improper {0}  {1} {2}".form(self.name, self.pot,
                                                    str(self.par))  
        else:
            return "improper {0:5d} {1:5d} {2:5d} {3:5d}".format(self.i + 1,
                   self.j + 1, self.k + 1, self.l + 1)


# --------------------------------------

class zmat(object):
    """z-matrix representing a molecule, read from .zmat file"""

    def __init__(self, filename):
        self.zatom = []
        self.connect = []
        self.improper = []
        
        with open(filename, 'r') as f:

            # read molecule name
            line = f.readline()
            while line.strip().startswith('#'):
                line = f.readline()
            self.name = line.strip()

            #read z-matrix
            line = f.readline()
            while line.strip().startswith('#') or line.strip() == '':
                line = f.readline()
            
            tok = line.strip().split()
            if len(tok) > 1:   # there can be line numbers
                shift = 1
            else:
                shift = 0

            variables = False
            while line and not line.strip().lower().startswith('var'):
                tok = line.strip().split()
                if len(tok) == 0:
                    break
                name = tok[shift]
                ir = ia = id = 0
                r = a = d = 0.0
                rvar = avar = dvar = ''
                if (len(tok) - shift) > 1:
                    ir = int(tok[shift+1])
                    if tok[shift+2][0].isalpha():
                        rvar = tok[shift+2]
                        variables = True
                    else:
                        r = float(tok[shift+2])
                    if (len(tok) - shift) > 3:
                        ia = int(tok[shift+3])
                        if tok[shift+4][0].isalpha():
                            avar = tok[shift+4]
                            variables = True
                        else:
                            a = float(tok[shift+4])
                        if (len(tok) - shift) > 5:
                            id = int(tok[shift+5])
                            if tok[shift+6][0].isalpha():
                                dvar = tok[shift+6]
                                variables = True
                            else:
                                d = float(tok[shift+6])
                zatom = {'name': name,
                        'ir': ir, 'rvar': rvar, 'r': r,
                        'ia': ia, 'avar': avar, 'a': a,
                        'id': id, 'dvar': dvar, 'd': d}
                self.zatom.append(zatom)
                line = f.readline()
                
            # read variables
            if variables:
                if line.strip().lower().startswith('var') or line.strip() == '':
                    line = f.readline()
                while line:
                    tok = line.strip().split('=')
                    if len(tok) < 2:
                        break
                    key = tok[0].strip()
                    val = float(tok[1])
                    for rec in self.zatom:
                        if rec['rvar'] == key:
                            rec['r'] = val
                        if rec['avar'] == key:
                            rec['a'] = val
                        if rec['dvar'] == key:
                            rec['d'] = val
                    line = f.readline()
                        
            # read connects, improper, force field file
            self.ff = ''
            self.guessconnect = False
            while line:
                if line.strip().startswith('#') or line.strip() == '':
                    line = f.readline()
                    continue
                tok = line.strip().split()
                if tok[0] == 'reconnect':
                    self.guessconnect = True
                if tok[0] == 'connect':
                    atomi = int(tok[1])
                    atomj = int(tok[2])
                    self.connect.append([atomi, atomj])
                elif tok[0] == 'improper':
                    atomi = int(tok[1])
                    atomj = int(tok[2])
                    atomk = int(tok[3])
                    atoml = int(tok[4])
                    self.improper.append([atomi, atomj, atomk, atoml])
                else:
                    self.ff = tok[0]
                line = f.readline()
                            
    def show(self):
        print(self.name)
        i = 0
        for rec in self.zatom:
            i += 1
            if rec['ir'] == 0:
                print('%-3d %-5s' % (i, rec['name']))
            elif rec['ia'] == 0:
                print('%-3d %-5s %3d %6.3f' % \
                      (i, rec['name'], rec['ir'], rec['r']))
            elif rec['id'] == 0:
                print('%-3d %-5s %3d %6.3f %3d %6.1f' % \
                    (i, rec['name'], rec['ir'], rec['r'], rec['ia'], rec['a']))
            else:
                print('%-3d %-5s %3d %6.3f %3d %6.1f %3d %6.1f' % \
                    (i, rec['name'], rec['ir'], rec['r'], rec['ia'], rec['a'],
                     rec['id'], rec['d']))
        if len(self.connect) > 0:
            print('connects')
            for c in self.connect:
                print('%3d (%5s) -- %3d (%5s)' % \
                    (c[0], self.zatom[c[0]-1]['name'],
                     c[1], self.zatom[c[1]-1]['name']))
        if self.ff:
            print('field: ' + self.ff)


# --------------------------------------


class mol(object):
    """molecule"""

    def __init__(self, filename, connect = True, box = None):
        self.atom = []
        self.bond = []
        self.angle = []
        self.dihed = []
        self.dimpr = []
        self.m = 0
        self.nmol = 0
        self.topol = 'none'
        
        try:
            with open(filename, 'r'):
                self.filename = filename
            ext = filename.split('.')[-1].strip().lower()
            if ext == 'zmat':
                self.fromzmat(filename, connect)
            elif ext == 'mol':
                self.frommdlmol(filename, connect)
            elif ext == 'xyz':
                self.fromxyz(filename, connect, box)
            elif ext == 'pdb':
                self.frompdb(filename, connect, box)
            else:
                print('  error: unsupported molecule file extension')
                sys.exit(1)
        except IOError:
            print('  error: molecule file not found')
            sys.exit(1)

        self.setff(box)
        
    def __str__(self):
        return 'molecule %s  %d atoms  m = %8.4f' % \
            (self.name, len(self.atom), self.m)

    def update_drudes(self, drude_terms):
        for i, at in enumerate(self.atom):
            if at.symbol == 'H':
                continue
            term = drude_terms.get(at.name, None)
            if term is None:
                print("  warning: drude parameters for atom '%s' not found" % at.name)
                continue

            at.drude=True
            at.md = term.md
            at.qd_base = term.qd_base
            at.kd = term.kd
            at.alpha = term.alpha
            at.thole = term.thole

            # merge the polarizability of H to connected heavy atoms
            for bd in self.bond:
                if i == bd.i:
                    a2 = self.atom[bd.j]
                elif i == bd.j:
                    a2 = self.atom[bd.i]
                else:
                    continue

                if a2.symbol == 'H':
                    term = drude_terms.get('H', None)
                    if term is None:
                        print("  error: drude parameters for atom 'H' is required")
                        sys.exit(1)
                    at.alpha += term.alpha

    @property
    def drudes(self):
        return [at for at in self.atom if at.drude]

    @property
    def n_atom(self):
        return len(self.atom)

    @property
    def n_drude(self):
        return len(self.drudes)

    @property
    def alpha(self):
        return sum([at.alpha for at in self.atom if at.drude])

    def get_aid_w_drude(self, i):
        return i + len([at for at in self.atom[:i] if at.drude])

    def charge(self):
        q = 0.0
        for at in self.atom:
            q += at.q
        return q

    def fromzmat(self, filename, connect):
        z = zmat(filename)
        self.name = z.name
        self.guessconnect = z.guessconnect
        self.ff = z.ff
        for zat in z.zatom:
            self.atom.append(atom(zat['name']))
            self.m += atomic_weight(zat['name'])
        self.zmat2cart(z)
        if connect and self.ff:          # topology only if ff defined
            if not self.guessconnect:
                for i in range(1, len(z.zatom)):
                    self.bond.append(bond(i, z.zatom[i]['ir'] - 1))
                for cn in z.connect:
                    self.bond.append(bond(cn[0] - 1, cn[1] - 1))
                self.topol = 'file'
            else:
                self.connectivity()
                self.topol = 'guess'
            for di in z.improper:                 
                self.dimpr.append(dimpr(di[0]-1, di[1]-1, di[2]-1, di[3]-1))
            self.anglesdiheds()
        return self
    
    def zmat2cart(self, z):
        natom = len(self.atom)    
        if natom != len(z.zatom):
            print('  error: different numbers of atoms in zmat ' + self.name)
            sys.exit(1)

        if natom == 0:
            return self

        # first atom at origin
        self.atom[0].x = 0.0
        self.atom[0].y = 0.0
        self.atom[0].z = 0.0
        if natom == 1:
            return self

        # second atom at distance r from first along xx
        self.atom[1].x = z.zatom[1]['r']
        self.atom[1].y = 0.0
        self.atom[1].z = 0.0
        if natom == 2:
            return self

        # third atom at distance r from ir forms angle a 3-ir-ia in plane xy
        r = z.zatom[2]['r']
        ir = z.zatom[2]['ir'] - 1
        ang = z.zatom[2]['a'] * math.pi / 180.0
        ia = z.zatom[2]['ia'] - 1

        # for this construction, the new atom is at point (x, y), atom
        # ir is at point (xr, yr) and atom ia is at point (xa, ya).
        # Theta is the angle between the vector joining ir to ia and
        # the x-axis, a' (= theta - a) is is the angle between r and
        # the x-axis. x = xa + r cos a', y = ya + r sin a'.  From the
        # dot product of a unitary vector along x with the vector from
        # ir to ia, theta can be calculated: cos theta = (xa - xr) /
        # sqrt((xa - xr)^2 + (ya - yr)^2).  If atom ia is in third or
        # forth quadrant relative to atom ir, ya - yr < 0, then theta
        # = 2 pi - theta. */
        delx = self.atom[ia].x - self.atom[ir].x
        dely = self.atom[ia].y - self.atom[ir].y
        theta = math.acos(delx / math.sqrt(delx*delx + dely*dely))
        if dely < 0.0:
            theta = 2 * math.pi - theta
        ang = theta - ang
        self.atom[2].x = self.atom[ir].x + r * math.cos(ang)
        self.atom[2].y = self.atom[ir].y + r * math.sin(ang)
        self.atom[2].z = 0.0
        if natom == 3:
            return self
        
        # nth atom at distance r from atom ir forms angle a at 3-ir-ia
        # and dihedral angle between planes 3-ir-ia and ir-ia-id
        for i in range(3, natom):
            r = z.zatom[i]['r']
            ir = z.zatom[i]['ir'] - 1
            ang = z.zatom[i]['a'] * math.pi / 180.0
            ia = z.zatom[i]['ia'] - 1
            dih = z.zatom[i]['d'] * math.pi / 180.0
            id = z.zatom[i]['id'] - 1

            # for this construction the new atom is at point A, atom ir is
            # at B, atom ia at C and atom id at D.  Point a is the
            # projection of A onto the plane BCD.  Point b is the
            # projection of A along the direction BC (the line defining
            # the dihedral angle between planes ABC and BCD). n = CD x BC
            # / |CD x BC| is the unit vector normal to the plane BCD. m =
            # BC x n / |BC x n| is the unit vector on the plane BCD normal
            # to the direction BC.
            #                               
            #                               .'A
            #                 ------------.' /.-----------------
            #                /           b /  .               /
            #               /           ./    .              /
            #              /           B......a      ^      /
            #             /           /              |n    /
            #            /           /                    /
            #           /           C                    /
            #          /             \                  /
            #         /               \                /
            #        /plane BCD        D              /
            #       ----------------------------------
            #
            #                    A              C------B...b
            #                   /.             /        .  .
            #                  / .            /    |m    . .
            #                 /  .           /     V      ..
            #         C------B...b          D              a
            #
            
            BA = r
            vB = vector(self.atom[ir].x, self.atom[ir].y, self.atom[ir].z)
            vC = vector(self.atom[ia].x, self.atom[ia].y, self.atom[ia].z)
            vD = vector(self.atom[id].x, self.atom[id].y, self.atom[id].z)

            vBC = vC - vB
            vCD = vD - vC
            
            BC = abs(vBC)
            bB = BA * math.cos(ang)
            bA = BA * math.sin(ang)
            aA = bA * math.sin(dih)
            ba = bA * math.cos(dih)

            vb = vC - vBC * ((BC - bB) / BC)
            vn = (vCD.cross(vBC)).unit()
            vm = (vBC.cross(vn)).unit()
            va = vb + vm * ba
            vA = va + vn * aA

            self.atom[i].x = vA.x
            self.atom[i].y = vA.y
            self.atom[i].z = vA.z
        return self
    
    def frommdlmol(self, filename, connect):
        with open(filename, 'r') as f:
            tok = f.readline().strip().split()
            self.name = tok[0]            # molecule name
            self.guessconnect = False
            if len(tok) > 1:              # and eventually ff file
                self.ff = tok[1]
                if len(tok) > 2:
                    if tok[2].startswith('rec'):
                        self.guessconnect = True
            else:
                self.ff = ''
            f.readline()                  # program/date info
            line = f.readline().strip()   # comment (eventually ff file)
            if line and not line.startswith('#') and not self.ff:
                tok = line.split()
                self.ff = tok[0]
                if len(tok) > 1:
                    if tok[1].startswith('rec'):
                        self.guessconnect = True
            line = f.readline()           # counts line
            natom = int(line[0:3])
            nbond = int(line[3:6])
            self.atom = [None] * natom
            for i in range(natom):
                tok = f.readline().strip().split()
                self.atom[i] = atom(tok[3])
                self.atom[i].x = float(tok[0])
                self.atom[i].y = float(tok[1])
                self.atom[i].z = float(tok[2])
            if connect and self.ff:      # topology only if ff defined
                if not self.guessconnect:
                    self.bond = [None] * nbond
                    for k in range(nbond):
                        line = f.readline()
                        i = int(line[0:3]) - 1
                        j = int(line[3:6]) - 1
                        self.bond[k] = bond(i, j)
                    self.topol = 'file'
                else:
                    self.connectivity()
                    self.topol = 'guess'
                self.anglesdiheds()
        return self
                                
    def fromxyz(self, filename, connect = False, box = None):
        with open(filename, 'r') as f:
            natom = int(f.readline().strip())
            self.atom = [None] * natom
            tok = f.readline().strip().split()
            self.name = tok[0]            # molecule name
            if len(tok) > 1:              # and eventually ff file
                self.ff = tok[-1]
            else:
                self.ff = ''
            for i in range(natom):
                tok = f.readline().strip().split()
                self.atom[i] = atom(tok[0])
                self.atom[i].x = float(tok[1])
                self.atom[i].y = float(tok[2])
                self.atom[i].z = float(tok[3])
        if connect and self.ff:
            self.connectivity(box)
            self.anglesdiheds()
            if isinstance(box, cell) and box.pbc:
                self.topol = 'pbc'
            else:
                self.topol = 'guess'
        return self

    def frompdb(self, filename, connect = False, box = None):
        with open(filename, 'r') as f:
            self.name = ''
            self.ff = ''
            line = f.readline()
            while not (line.startswith('HETATM') or line.startswith('ATOM  ')):
                if line.startswith('COMPND'):
                    tok = line.strip().split()
                    self.name = tok[1]
                    if len(tok) >= 3: 
                        self.ff = tok[2]
                line = f.readline()
            self.atom = []
            i = 0
            while line[0:6] == 'HETATM' or line[0:6] == 'ATOM  ':
                atname = line[12:16].strip()
                self.atom.append(atom(atname))
                self.atom[i].x = float(line[30:38])
                self.atom[i].y = float(line[38:46])
                self.atom[i].z = float(line[46:54])
                i += 1
                line = f.readline()
        if connect and self.ff:           # TODO read conect
            self.connectivity(box)
            self.anglesdiheds()
            if isinstance(box, cell) and box.pbc:
                self.topol = 'pbc'
            else:
                self.topol = 'guess'
        return self
    
    def connectivity(self, box = None):    
        """determine connectivity from bond distances in force field"""

        ff = forcefield(self.ff)
        error = False
        for at in self.atom:
            found = False
            for ffat in ff.atom:     
                if at.name == ffat.name:
                    at.type = ffat.type
                    found = True
            if not found:
                print("  error in {0}: no parameters for atom "\
                      "{1}".format(self.name, at.name))
                error = True
        if error:
            sys.exit(1)

        natom = len(self.atom)
        for i in range(0, natom-1):
            for j in range(i+1, natom):
                r = dist2atoms(self.atom[i], self.atom[j], box)
                names = [ '{0}-{1}'.format(self.atom[i].type,
                                           self.atom[j].type),
                          '{0}-{1}'.format(self.atom[j].type,
                                           self.atom[i].type) ]
                for ffbd in ff.bond:
                    nameff = '{0}-{1}'.format(ffbd.iatp, ffbd.jatp)
                    if nameff in names:
                        if ffbd.checkval(r):
                            self.bond.append(bond(i, j))
                                        
    def anglesdiheds(self):
        """identify angles and dihedrals based on bond connectivity"""
                 
        natom = len(self.atom)
        nbond = len(self.bond)

        # identify valence angles
        for i in range(natom):  # find neighbour atoms to each atom i
            nb = 0
            neib = []
            for bd in self.bond:          
                if i == bd.i:
                    neib.append(bd.j)
                    nb += 1
                elif i == bd.j:
                    neib.append(bd.i)
                    nb += 1
            for k in range(nb - 1):
                for l in range(k + 1, nb):
                    self.angle.append(angle(neib[k], i, neib[l]))

        # identify dihedral angles
        for k in range(nbond): # find bonds around non-terminal bonds
            for l in range(nbond):
                if l == k:
                    continue
                if self.bond[l].i == self.bond[k].i:
                    for j in range(nbond):
                        if j == k or j == l:
                            continue
                        if self.bond[j].i == self.bond[k].j:
                            self.dihed.append(dihed(self.bond[l].j,
                                                    self.bond[k].i,
                                                    self.bond[k].j,
                                                    self.bond[j].j))
                        elif self.bond[j].j == self.bond[k].j:
                            self.dihed.append(dihed(self.bond[l].j,
                                                    self.bond[k].i,
                                                    self.bond[k].j,
                                                    self.bond[j].i))
                elif self.bond[l].j == self.bond[k].i:
                    for j in range(nbond):
                        if j == k or j == l:
                            continue
                        if self.bond[j].i == self.bond[k].j:
                            self.dihed.append(dihed(self.bond[l].i,
                                                    self.bond[k].i,
                                                    self.bond[k].j,
                                                    self.bond[j].j))
                        elif self.bond[j].j == self.bond[k].j:
                            self.dihed.append(dihed(self.bond[l].i,
                                                    self.bond[k].i,
                                                    self.bond[k].j,
                                                    self.bond[j].i))

        # identify possible impropers if not supplied with z-matrix
        if not self.dimpr:
            for i in range(natom):  # find atoms with 3 neighbours
                nb = 0
                neib = []
                for bd in self.bond:          
                    if i == bd.i:
                        neib.append(bd.j)
                        nb += 1
                    elif i == bd.j:
                        neib.append(bd.i)
                        nb += 1
                if nb == 3:
                    self.dimpr.append(dimpr(neib[0], neib[1], i, neib[2]))
        
        # remove duplicate impropers differing by i-j or j-i
        toremove = []
        for i in range(len(self.dimpr) - 1):
            for j in range(i + 1, len(self.dimpr)):
                if self.dimpr[i].i == self.dimpr[j].j and \
                    self.dimpr[i].j == self.dimpr[j].i or \
                    self.dimpr[i].i == self.dimpr[j].i and \
                    self.dimpr[i].j == self.dimpr[j].j:
                    if self.dimpr[j] not in toremove:
                        toremove.append(self.dimpr[j])
        for di in toremove:
            self.dimpr.remove(di)

        return self
    
    def setff(self, box = None):
        """set force field parameters"""
        
        if not self.ff:
            for at in self.atom:
                at.setpar(at.name, 0.0, 'lj', [0.0, 0.0])
            return self
        
        ff = forcefield(self.ff)

        # identify atom types and set parameters
        for at in self.atom:
            found = False
            for ffat in ff.atom:     
                if at.name == ffat.name:
                    if found:
                        print("  warning: duplicate atom {0} in "\
                              "{1}".format(at.name, self.ff))     
                    at.setpar(ffat.type, ffat.q, ffat.pot, ffat.par)
                    at.m = ffat.m
                    found = True
            if not found:
                print("  error in {0}: no parameters for atom "\
                      "{1}".format(self.name, at.name))
                sys.exit(1)
            
        # identify bonded terms and set parameters
        # even if parameters does not exist, topol information is required for building 1-2 1-3 1-4 pair list
        self.bond_topol = self.bond[:]
        for bd in self.bond:
            ti = self.atom[bd.i].type
            tj = self.atom[bd.j].type
            names = [ '{0}-{1}'.format(ti, tj), '{0}-{1}'.format(tj, ti) ]
            r = dist2atoms(self.atom[bd.i], self.atom[bd.j], box)
            found = False
            for ffbd in ff.bond:
                nameff = '{0}-{1}'.format(ffbd.iatp, ffbd.jatp)
                if nameff in names:
                    bd.setpar(ffbd.iatp, ffbd.jatp, ffbd.pot, ffbd.par)
                    if not ffbd.checkval(r):
                        print('  warning: %s bond %s %d-%d %7.3f' % \
                          (self.name, bd.name, bd.i + 1, bd.j + 1, r))
                    if found:
                        print("  warning: duplicate bond {0} in "\
                              "{1}".format(bd.name, self.ff))
                    found = True
            if not found:
                print("  error in {0}: no parameters for bond "\
                      "{1}".format(self.name, names[0]))
                sys.exit(1)

        anmiss = []
        dhmiss = []
        dimiss = []

        # even if parameters does not exist, topol information is required for building 1-2 1-3 1-4 pair list
        self.angle_topol = self.angle[:]
        toremove = []
        for an in self.angle:
            ti = self.atom[an.i].type
            tj = self.atom[an.j].type
            tk = self.atom[an.k].type
            names = [ '%s-%s-%s' % (ti, tj, tk), '%s-%s-%s' % (tk, tj, ti) ]
            th = angle3atoms(self.atom[an.i], self.atom[an.j], self.atom[an.k],
                             box)
            found = False
            check = True
            for ffan in ff.angle:
                nameff = '%s-%s-%s' % (ffan.iatp, ffan.jatp, ffan.katp)
                if nameff in names:
                    an.setpar(ffan.iatp, ffan.jatp, ffan.katp,
                              ffan.pot, ffan.par)                        
                    if not ffan.checkval(th):
                        check = False
                    if found:
                        print("  warning: duplicate angle {0} in "\
                              "{1}".format(an.name, self.ff))
                    found = True
            if not check:
                toremove.append(an)
                print('  warning: %s angle %s %d-%d-%d %.2f removed' % \
                    (self.name, an.name, an.i+1, an.j+1, an.k+1, th))
            if not found:
                toremove.append(an)
                if names[0] not in anmiss:
                    anmiss.append(names[0])
        for an in toremove:
            self.angle.remove(an)

        # even if parameters does not exist, topol information is required for building 1-2 1-3 1-4 pair list
        self.dihed_topol = self.dihed[:]
        toremove = []
        for dh in self.dihed:
            ti = self.atom[dh.i].type
            tj = self.atom[dh.j].type
            tk = self.atom[dh.k].type
            tl = self.atom[dh.l].type
            names = [ '%s-%s-%s-%s' % (ti, tj, tk, tl),
                      '%s-%s-%s-%s' % (tl, tk, tj, ti) ]
            found = False
            for ffdh in ff.dihed:
                nameff = '%s-%s-%s-%s' % \
                  (ffdh.iatp, ffdh.jatp, ffdh.katp, ffdh.latp)
                if nameff in names:
                    dh.setpar(ffdh.iatp, ffdh.jatp, ffdh.katp, ffdh.latp,
                              ffdh.pot, ffdh.par)
                    if found:
                        print("  warning: duplicate dihedral {0} in "\
                              "{1}".format(dh.name, self.ff))
                    found = True
            if not found:
                toremove.append(dh)
                if names[0] not in dhmiss:
                    dhmiss.append(names[0])
        for dh in toremove:
            self.dihed.remove(dh)
        
        toremove = []
        for di in self.dimpr:
            ti = self.atom[di.i].type
            tj = self.atom[di.j].type
            tk = self.atom[di.k].type
            tl = self.atom[di.l].type
            names = [ '%s-%s-%s-%s' % (ti, tj, tk, tl),
                      '%s-%s-%s-%s' % (tj, ti, tk, tl),
                      '%s-%s-%s-%s' % (ti, tl, tk, tj),
                      '%s-%s-%s-%s' % (tl, ti, tk, tj),
                      '%s-%s-%s-%s' % (tj, tl, tk, ti),
                      '%s-%s-%s-%s' % (tl, tj, tk, ti) ]
            found = False
            for ffdi in ff.dimpr:
                nameff = '%s-%s-%s-%s' % \
                  (ffdi.iatp, ffdi.jatp, ffdi.katp, ffdi.latp)
                if nameff in names:
                    # sort atom numbering according to impropers in ff
                    if nameff == names[1] and tj != ti:
                        di.i, di.j = di.j, di.i
                    elif nameff == names[2] and tl != tj:
                        di.j, di.l = di.l, di.j
                    elif nameff == names[3]:
                        if tl != tj:
                            di.j, di.l = di.l, di.j
                        if tj != ti:
                            di.i, di.j = di.j, di.i
                    elif nameff == names[4]:
                        if tl != ti:
                            di.i, di.l = di.l, di.i
                        if tj != ti:
                            di.i, di.j = di.j, di.i
                    elif nameff == names[5] and tl != ti:
                        di.i, di.l = di.l, di.i
                    di.setpar(ffdi.iatp, ffdi.jatp, ffdi.katp, ffdi.latp,
                              ffdi.pot, ffdi.par)
                    if found:
                        print("  warning: duplicate improper {0} in "\
                              "{1}".format(di.name, self.ff))
                    found = True
            if not found:
                toremove.append(di)
                if names[0] not in dimiss:
                    dimiss.append(names[0])
        for di in toremove:
            self.dimpr.remove(di)

        if len(anmiss) or len(dhmiss) or len(dimiss):
            print('  warning: missing force field parameters')
            for s in anmiss:
                print('    angle type ' + s)
            for s in dhmiss:
                print('    dihedral type ' + s)
            for s in dimiss:
                print('    improper type ' + s)

    def show(self):
        print("{0}: {1:d} molecules".format(self.name, self.nmol))
        print("{0:d} atoms".format(len(self.atom)))
        n = 0
        for at in self.atom:
            n += 1
            print("{0:5d} ".format(n) + str(at))
        print("{0:d} bonds".format(len(self.bond)))
        for bd in self.bond:
            print(bd)
        print("{0:d} angles".format(len(self.angle)))
        for an in self.angle:
            print(an)
        print("{0:d} dihedrals".format(len(self.dihed)))
        for dh in self.dihed:
            print(dh)
        print("{0:d} improper".format(len(self.dimpr)))
        for di in self.dimpr:
            print(di)
        if self.ff:
            print('field: ' + self.ff)

    def showxyz(self, symbol = False):
        print(len(self.atom))
        if self.ff:
            print(self.name + ' ' + self.ff)
        else:
            print(self.name)
        for at in self.atom:
            if symbol:
                atname = atomic_symbol(at.name)
            else:
                atname = at.name
            print("{0:5s} {1:15.6f} {2:15.6f} {3:15.6f}".format(atname,
                                                         at.x, at.y, at.z))

    def writexyz(self, symbol = True):
        outfile = (self.filename).rsplit('.', 1)[0] + '_pack.xyz'
        with open(outfile, 'w') as f:
            f.write(str(len(self.atom)) + '\n')
            if self.ff:
                f.write(self.name + ' ' + self.ff + '\n')
            else:
                f.write(self.name + '\n')
            for at in self.atom:
                if symbol:
                    atname = atomic_symbol(at.name)
                else:
                    atname = at.name
                f.write("{0:5s} {1:15.6f} {2:15.6f} {3:15.6f}\n".format(\
                        atname, at.x, at.y, at.z))

    def showpdb(self):
        print('COMPND    ' + self.name)
        if self.ff:
            print('REMARK    ' + self.ff)
        i = 1
        for at in self.atom:
            print('HETATM{0:5d} {1:4s} {2:3s}  {3:4d}    '\
                  '{4:8.3f}{5:8.3f}{6:8.3f}  1.00  0.00'\
                  '          {7:2s}'.format(i, at.name,
                  self.name[0:3], 1, at.x, at.y, at.z,
                  atomic_symbol(at.name)))
            i += 1
        print("END")

    def writepdb(self):
        outfile = (self.filename).rsplit('.', 1)[0] + '.pdb'
        with open(outfile, 'w') as f:
            f.write('COMPND    ' + self.name + '\n')
            if self.ff:
                f.write('REMARK    ' + self.ff + '\n')
            i = 1
            for at in self.atom:
                f.write('HETATM{0:5d} {1:4s} {2:3s}  {3:4d}    '\
                        '{4:8.3f}{5:8.3f}{6:8.3f}  1.00  0.00'\
                        '          {7:2s}\n'.format(i, at.name,
                        self.name[:3], 1, at.x, at.y, at.z,
                        atomic_symbol(at.name)))
                i += 1
            f.write("END\n")              # TODO write conect


# --------------------------------------


class forcefield(object):
    """force field parameter database"""

    def __init__(self, filename):
        self.filename = filename
        self.atom = []
        self.bond = []
        self.angle = []
        self.dihed = []
        self.dimpr = []

        try:
            with open(filename, 'r') as f:
                i = ib = ia = ih = im = 0
                for line in f:
                    if line.startswith('#') or line.strip() == '':
                        continue
                
                    if line.lower().startswith('atom'):
                        section = 'atoms'
                        continue
                    elif line.lower().startswith('bond'):
                        section = 'bonds'
                        continue
                    elif line.lower().startswith('angl'):
                        section = 'angles'
                        continue
                    elif line.lower().startswith('dihe'):
                        section = 'dihedrals'
                        continue
                    elif line.lower().startswith('impro'):
                        section = 'improper'
                        continue

                    tok = line.strip().split()

                    if section == 'atoms':
                        name = tok[0]
                        attp = tok[1]
                        m = float(tok[2])
                        q = float(tok[3])
                        pot = tok[4]
                        par = [float(p) for p in tok[5:]]
                        self.atom.append(atom(name, m))
                        self.atom[i].setpar(attp, q, pot, par)
                        i += 1

                    elif section == 'bonds':
                        iatp = tok[0]
                        jatp = tok[1]
                        pot = tok[2]
                        par = [float(p) for p in tok[3:]]
                        self.bond.append(bond())
                        self.bond[ib].setpar(iatp, jatp, pot, par)
                        ib += 1

                    elif section == 'angles':
                        iatp = tok[0]
                        jatp = tok[1]
                        katp = tok[2]
                        pot = tok[3]
                        par = [float(p) for p in tok[4:]]
                        self.angle.append(angle())
                        self.angle[ia].setpar(iatp, jatp, katp, pot, par)
                        ia += 1

                    elif section == 'dihedrals':
                        iatp = tok[0]
                        jatp = tok[1]
                        katp = tok[2]
                        latp = tok[3]
                        pot = tok[4]
                        par = [float(p) for p in tok[5:]]
                        self.dihed.append(dihed())
                        self.dihed[ih].setpar(iatp, jatp, katp, latp, pot, par)
                        ih += 1

                    elif section == 'improper':
                        iatp = tok[0]
                        jatp = tok[1]
                        katp = tok[2]
                        latp = tok[3]
                        pot = tok[4]
                        par = [float(p) for p in tok[5:]]
                        self.dimpr.append(dimpr())
                        self.dimpr[im].setpar(iatp, jatp, katp, latp, pot, par)
                        im += 1

        except IOError:
            print('  error: force field file ' + filename + ' not found')
            sys.exit(1)
                        
        for bn in self.bond:
            bn.seteqval()
        for an in self.angle:
            an.seteqval()
                    
    def show(self):
        for at in self.atom:
            print(at)
        for bd in self.bond:
            print(bd)
        for an in self.angle:
            print(an)
        for dh in self.dihed:
            print(dh)
        for di in self.dimpr:
            print(di)


class vdw(object):
    """van der Waals interaction"""        
    
    def __init__(self, iat, jat, mix = 'g'):
        self.i = iat.name                     # atom type of first atom, in str
        self.j = jat.name
        self.ityp = iat.ityp                  # atom type index of first atom, starts from 0
        self.jtyp = jat.ityp
        self.par = [0.0, 0.0, 0.0, 0.0]       # sigma, epsilon, alpha, thole
        self.name = '%s %s' %(iat.name, jat.name)
        self.extra = []                       # extra information for comment

        if iat.pot != jat.pot:
            print('  error in vdw object: incompatible potential types ' + \
              self.i + ' ' + self.j)
            sys.exit(1)

        self.pot = iat.pot

        if len(iat.par) != len(jat.par):
            print('  error in vdw object: different lengths in parameter ' \
                  'lists ' + self.i + ' ' + self.j)
            sys.exit(1)

        if self.pot == 'lj':
            if mix == 'g':
                self.par[0] = math.sqrt(iat.par[0] * jat.par[0])
            else:
                self.par[0] = (iat.par[0] + jat.par[0]) / 2.
            self.par[1] = math.sqrt(iat.par[1] * jat.par[1])
            self.par[2] = math.sqrt(iat.alpha * jat.alpha)
            self.par[3] = (iat.thole + jat.thole) / 2.

    def __str__(self):
        return 'vdw %2s %2s  %s %s' % (self.i, self.j, self.pot, str(self.par))

    @property
    def sigma(self):
        return self.par[0]

    @sigma.setter
    def sigma(self, val):
        self.par[0] = val

    @property
    def epsilon(self):
        return self.par[1]

    @epsilon.setter
    def epsilon(self, val):
        self.par[1] = val

    @property
    def comment(self):
        if self.extra == []:
            return ''
        else:
            return ' ' + ' '.join(['%6s' %e for e in self.extra])

class DrudeTerm():
    def __init__(self, md, qbase, kd, alpha, thole):
        self.md = md
        self.qd_base = qbase
        self.kd=kd
        self.alpha = alpha
        self.thole = thole

    @staticmethod
    def read_file(file):
        terms = {}
        with open(file) as f:
            lines = f.read().splitlines()
        for line in lines:
            if line.startswith('#') or line.strip() == '':
                continue
            words = line.strip().split()
            terms[words[0]] = DrudeTerm(*map(float, words[1:6]))

        return terms

# --------------------------------------

class Monomer():
    def __init__(self, name, charge, dipole, alpha):
        self.name = name
        self.charge = charge
        self.dipole = dipole
        self.alpha = alpha
        self.atoms = []  # list of atom names

    def __repr__(self):
        return '<Monomer: %s>' %self.name

class Dimer():
    def __init__(self, m1, m2, distance):
        self.monomer1 = m1
        self.monomer2 = m2
        self.distance = distance

    def __repr__(self):
        return '<Dimer: %s %s>' % (self.monomer1.name, self.monomer2.name)

class LJScaler():
    C0 = 0.25
    C1 = 0.11

    def __init__(self):
        self.monomers = []
        self.dimers = []

    def read_scale_inp(self, file):
        with open(file) as f:
            lines = f.read().splitlines()

        for line in lines:
            if line.strip() == '' or line.startswith('#'):
                continue

            words = line.strip().split()
            if words[0] == 'MONOMERS':
                section = 'MONOMERS'
                continue
            elif words[0] == 'DIMERS':
                section = 'DIMERS'
                continue
            elif words[0] == 'K_SAPT2':
                section = 'K_SAPT2'
                continue
            elif words[0] == 'ATOMS':
                section = 'ATOMS'
                continue

            if section == 'MONOMERS':
                name = words[0].strip('+').strip('-')
                alpha = -1
                if len(words) > 3:
                    alpha = float(words[3])
                self.monomers.append(Monomer(name, float(words[1]), float(words[2]), alpha))

            elif section == 'DIMERS':
                m1 = filter(lambda x: x.name==words[0], self.monomers).__next__()
                m2 = filter(lambda x: x.name==words[1], self.monomers).__next__()
                self.dimers.append(Dimer(m1, m2, float(words[2])))

            elif section == 'ATOMS':
                monomer = filter(lambda x: x.name==words[0], self.monomers).__next__()
                monomer.atoms = words[1:]

    def pred_scale_factor(self, atom1, atom2):
        '''

        :param atom1:
        :param atom2:
        :return: k = -1 means dimer data not found. will not scale
                 k = positive float means scale normally
        '''
        for monomer in self.monomers:
            if atom1 in monomer.atoms:
                m1 = monomer
                break
        else:
            print('  error in predicting scaling factor: atom not recognized: %s' % atom1.name)
            sys.exit(1)

        for monomer in self.monomers:
            if atom2 in monomer.atoms:
                m2 = monomer
                break
        else:
            print('  error in predicting scaling factor: atom not recognized: %s' % atom2.name)
            sys.exit(1)

        for di in self.dimers:
            if (m1 == di.monomer1 and m2 == di.monomer2) or (m2 == di.monomer1 and m1 == di.monomer2 ):
                dimer = di
                break
        else:
            print('  warning: dimer data for \'%s %s\' not found ! Will not scale epsilon: %s %s' %(
                m1.name, m2.name, atom1, atom2))
            return -1

        if (m1.charge != 0 or m1.dipole != 0) and m1.alpha == -1:
            print('  error: alpha required for charged or polar fragment: %s' % m1.name)
            sys.exit(1)

        if (m2.charge != 0 or m2.dipole != 0) and m2.alpha == -1:
            print('  error: alpha required for charged or polar fragment: %s' % m2.name)
            sys.exit(1)

        k = self.C0 * dimer.distance**2 *(m1.charge**2 / m1.alpha +
                                          m2.charge**2 / m2.alpha)+ \
            self.C1 * (m1.dipole ** 2 / m1.alpha + m2.dipole ** 2 / m2.alpha)
        return round(1 / (1+k), 3)

    def scale_eps(self, term):
        k = self.pred_scale_factor(term.i, term.j)
        if k == -1:
            return
        term.epsilon *= k
        term.extra.append('eps*%.3f' % k )

    def scale_sig(self, term, factor):
        if factor == 1.0:
            return
        term.sigma *= factor
        term.extra.append('sig*%.3f' % factor)

# --------------------------------------


class cell(object):
    """Simulation cell/box, cubic, orthorhombic, monoclinic or triclinic"""

    def __init__(self, a, b = 0.0, c = 0.0,
                 alpha = 90.0, beta = 90.0, gamma = 90.0,
                 pbc = '', center = False):
        self.a = a
        if b == 0.0:
            self.b = a
        else:
            self.b = b
        if c == 0.0:
            self.c = a
        else:
            self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        if alpha != 90.0 or beta != 90.0 or gamma != 90.0:
            self.triclinic = True
        else:
            self.triclinic = False

        self.pbc = pbc                    # 'x', 'xy', 'xyz', etc.
        self.center = center
        
        NDIG = 14
        ca = round(math.cos(alpha * math.pi/180.0), NDIG);
        cb = round(math.cos(beta  * math.pi/180.0), NDIG);
        cg = round(math.cos(gamma * math.pi/180.0), NDIG);
        sg = round(math.sin(gamma * math.pi/180.0), NDIG);

        self.vol = v = a*b*c*math.sqrt(1 - ca*ca - cb*cb - cg*cg + 2*ca*cb*cg)

        # to convert between cartesian and fractional coords
        self.ftocmat = [[   a, b*cg, c*cb              ],
                        [ 0.0, b*sg, c*(ca - cb*cg)/sg ],
                        [ 0.0,  0.0, v/(a*b*sg)        ]]
        self.ctofmat = [[ 1.0/a, -cg/(a*sg), b*c*(ca*cg - cb)/(v*sg) ],
                        [   0.0, 1.0/(b*sg), a*c*(cb*cg - ca)/(v*sg) ],
                        [   0.0,        0.0, a*b*sg/v                ]]

        # box sizes and tilt factors
        self.lx = a
        self.xy = b*cg
        self.xz = c*cb
        # self.ly = math.sqrt(b*b - self.xy*self.xy)
        # self.yz = (b*ca - self.xy*self.xz)/self.ly
        # self.lz = math.sqrt(c*c - self.xz*self.xz - self.yz*self.yz)
        self.ly = b*sg
        self.yz = c*(ca - cb*cg)/sg
        self.lz = v/(a*b*sg)

    def ftoc(self, x):
        return [ sum(a*b for a,b in zip(row, x)) for row in self.ftocmat ]

    def ctof(self, x):
        return [ sum(a*b for a,b in zip(row, x)) for row in self.ctofmat ]


class plane():
    """Plane passing through 3 points. p, q, r vector objects."""

    def __init__(self, p, q, r):
        u = q - p
        v = r - p
        w = u.cross(v)
        self.a = w.x
        self.b = w.y
        self.c = w.z
        self.d = w * p

    def __str__(self):
        return "{0:.4f} {1:.4f} {2:.4f} {3:.4f}".format(
               self.a, self.b, self.c, self.d)


# --------------------------------------


class system(object):
    """Molecular system to be simulated"""

    def __init__(self, spec, box, mix = 'g', drudeff=None, scaleeps=None, scalesig=1.0, allpairs=False):
        self.spec = spec                     # molecular species
        self.box = box

        self.attype = []                     # atom types
        self.bdtype = []                     # bond types
        self.antype = []                     # angle types
        self.dhtype = []                     # dihedral types
        self.ditype = []                     # improper types
        self.vdw = []
        self.vdw_drude = []
        self.mix = mix
        self.allpairs = allpairs or (scaleeps is not None) or scalesig != 1.0
        self.is_drude = drudeff is not None
        if self.is_drude:
            drude_terms = DrudeTerm.read_file(drudeff)
            for sp in self.spec:
                sp.update_drudes(drude_terms)

        # build lists of different atom and bonded term types in the system
        for sp in self.spec:
            self.build_type_list(sp.atom, self.attype)
            self.build_type_list(sp.bond, self.bdtype)
            self.build_type_list(sp.angle, self.antype)
            self.build_type_list(sp.dihed, self.dhtype)
            self.build_type_list(sp.dimpr, self.ditype)

        # build lists of drude atoms
        self.attype_drude = [at for at in self.attype if at.drude]
        
        # assign the type index for all atoms and bonded terms in the system
        for sp in self.spec:
            self.assign_type_index(sp.atom, self.attype)
            self.assign_type_index(sp.bond, self.bdtype)
            self.assign_type_index(sp.angle, self.antype)
            self.assign_type_index(sp.dihed, self.dhtype)
            self.assign_type_index(sp.dimpr, self.ditype)

        # save the type index for drude particles
        for i, att in enumerate(self.attype_drude):
            att.ityp_drude = i + len(self.attype)
            att.ibtyp_drude = i + len(self.bdtype)

        # set non-bonded parameters for all i-j pairs
        nattypes = len(self.attype)
        for i in range(nattypes):
            for j in range(i, nattypes):
                self.vdw.append(vdw(self.attype[i], self.attype[j], mix))

        # set non-bonded parameters for all i-j pairs containing drude types
        for iat in self.attype:
            for jat in self.attype_drude:
            # for jat in filter(lambda x: x.drude, self.attype):
                vd = vdw(iat, jat, mix)
                vd.jtyp = jat.ityp_drude
                vd.name = '%s %s-DP' %(iat.name, jat.name)
                self.vdw_drude.append(vd)
        for iat in self.attype_drude:
            for jat in filter(lambda x: x.ityp_drude >= iat.ityp_drude, self.attype_drude):
                vd = vdw(iat, jat, mix)
                vd.ityp = iat.ityp_drude
                vd.jtyp = jat.ityp_drude
                vd.name = '%s-DP %s-DP' % (iat.name, jat.name)
                self.vdw_drude.append(vd)

        ############# Scale LJ
        scaler = LJScaler()
        if scaleeps is not None:
            scaler.read_scale_inp(scaleeps)
            for vd in self.vdw:
                scaler.scale_eps(vd)
        if scalesig != 1.0:
            for vd in self.vdw:
                scaler.scale_sig(vd, scalesig)
        ######################

    def build_type_list(self, term, termtype):
        """build a list of atom or bonded term types"""        
        for a in term:
            found = False
            for b in termtype:
                if a.name == b.name:
                    found = True
            if not found:
                termtype.append(a)

    def assign_type_index(self, term, termtype):
        """assign numbers to the ityp attribute in atoms or bonded terms"""
        ntypes = len(termtype)
        for a in term:
            for i in range(ntypes):
                if a.name == termtype[i].name:
                    a.ityp = termtype[i].ityp = i
                    break       

    def show(self):
        for sp in self.spec:
            print('%s  %d molecules force field %s' % (sp.name, sp.nmol, sp.ff))
            for at in sp.atom:
                print(at)
            for bd in sp.bond:
                print(bd)
            for an in sp.angle:
                print(an)
            for dh in sp.dihed:
                print(dh)
            for di in sp.dimpr:
                print(di)
        for nb in self.vdw:
            print(nb)

    def writepackmol(self, packfile, outfile, tol = 2.5, d = 0.0):
        with open(packfile, 'w') as f:
            f.write("# created by fftool\n")
            f.write("tolerance {0:3.1f}\n".format(tol))
            f.write("filetype xyz\n")
            f.write("output {0}\n".format(outfile))
            for sp in self.spec:
                xyzfile = (sp.filename).rsplit('.', 1)[0] + '_pack.xyz'
                f.write("\nstructure {0}\n".format(xyzfile))
                f.write("  number {0}\n".format(sp.nmol))
                if self.box.triclinic:
                    o = vector(0.0, 0.0, 0.0)
                    p = vector(self.box.lx, 0.0, 0.0)
                    q = vector(self.box.xy, self.box.ly, 0.0)
                    r = vector(self.box.xz, self.box.yz, self.box.lz)
                    s = p + r
                    t = q + r
                    u = s + q
                    v = p + q
                    back = plane(o, p, q)
                    front = plane(r, s, t)
                    bottom = plane(o, r, p)
                    top = plane(q, t, v)
                    left = plane(o, q, r)
                    right = plane(p, v, s)
                    f.write("  over plane {0}\n".format(back))
                    f.write("  below plane {0}\n".format(front))
                    f.write("  over plane {0}\n".format(bottom))
                    f.write("  below plane {0}\n".format(top))
                    f.write("  over plane {0}\n".format(left))
                    f.write("  below plane {0}\n".format(right))
                else:
                    if self.box.center:
                        f.write("  inside box {0:.4f} {1:.4f} {2:.4f} {3:.4f}"
                                " {4:.4f} {5:.4f}\n".format(
                                -self.box.a / 2.0 + d,
                                -self.box.b / 2.0 + d,
                                -self.box.c / 2.0 + d,
                                 self.box.a / 2.0 - d,
                                 self.box.b / 2.0 - d,
                                 self.box.c / 2.0 - d))
                    else:
                        f.write("  inside box {0:.4f} {1:.4f} {2:.4f} {3:.4f}"
                                " {4:.4f} {5:.4f}\n".format(d, d, d,
                            self.box.a - d, self.box.b - d, self.box.c - d))
                f.write('end structure\n')

    def readcoords(self, filename):
        try:
            with open(filename, 'r') as f:
                self.natom = int(f.readline().strip())
                self.x = [0.0] * self.natom
                self.y = [0.0] * self.natom
                self.z = [0.0] * self.natom
                tok = f.readline().strip().split()
                self.title = tok[0]
                for i in range(self.natom):
                    tok = f.readline().strip().split()
                    self.x[i] = float(tok[1])
                    self.y[i] = float(tok[2])
                    self.z[i] = float(tok[3])
        except IOError:
            print('  error: coordinates file ' + filename + ' not found')
            sys.exit(1)

    def writelmp(self, units = 'r'):
        natom = ndrude = nbond = nangle = ndihed = 0
        for sp in self.spec:
            natom += sp.nmol * len(sp.atom)
            nbond += sp.nmol * len(sp.bond)
            nangle += sp.nmol * len(sp.angle)
            ndihed += sp.nmol * (len(sp.dihed) + len(sp.dimpr))
            
            if self.is_drude:
                ndrude += sp.nmol * sp.n_drude
        
        with open('in.lmp', 'w') as f:
            f.write('# created by fftool\n\n')
            if units == 'r':
                f.write('units real\n')
                ecnv = kCal
            elif units == 'm':
                f.write('units metal\n')
                ecnv = eV
            else:
                print('unknown units for lammps files')
                sys.exit(1)
                
            f.write('boundary p p p\n\n')

            f.write('atom_style full\n')
            if nbond:
                f.write('bond_style harmonic\n')
            if nangle:
                f.write('angle_style harmonic\n')
            if ndihed:
                f.write('dihedral_style opls\n')
            f.write('\n')
            
            f.write('special_bonds lj/coul 0.0 0.0 0.5\n\n')

            if self.is_drude:
                f.write('pair_style lj/cut/thole/long 2.6 12.0\n')
            else:
                f.write('pair_style lj/cut/coul/long 12.0\n')

            if self.mix == 'g':
                f.write('pair_modify mix geometric tail yes\n')
            else:
                f.write('pair_modify mix arithmetic tail yes\n')
            f.write('kspace_style pppm 1.0e-5\n\n')

            f.write('read_data data.lmp extra/special/per/atom 99\n')
            f.write('# read_restart restart1.lmp\n\n')

            if not self.allpairs:
                if not self.is_drude:
                    for att in self.attype:
                        f.write('pair_coeff %4d %4d %12.6f %12.6f  # %s %s\n' % \
                                (att.ityp + 1, att.ityp + 1,
                                 att.par[1] / ecnv, att.par[0], att.name, att.name))
                else:
                    for att in self.attype:
                        f.write('pair_coeff %4d %4d %12.6f %12.6f %8.4f %7.3f  '\
                                 '# %s %s\n' % \
                                 (att.ityp + 1, att.ityp + 1,
                                  att.par[1] / ecnv, att.par[0],
                                  att.alpha, att.thole, att.name, att.name))
                    for att in self.attype_drude:
                        f.write('pair_coeff %4d %4d %12.6f %12.6f %8.4f %7.3f  '\
                                 '# %s %s DP\n' % \
                                 (att.ityp_drude + 1, att.ityp_drude + 1,
                                  0, 0, att.alpha, att.thole, att.name, att.name))
                f.write('\n')

            else:
                f.write('include pair.lmp\n\n')
                with open('pair.lmp', 'w') as fp:
                    if not self.is_drude:
                        for nb in self.vdw:
                            fp.write('pair_coeff %4d %4d %12.6f %12.6f  # %s\n' % \
                                    (nb.ityp + 1, nb.jtyp + 1,
                                     nb.par[1] / ecnv, nb.par[0], nb.name + nb.comment))
                    else:
                        for nb in self.vdw:
                            fp.write('pair_coeff %4d %4d %12.6f %12.6f %8.4f %7.3f  ' \
                                     '# %s\n' % \
                                     (nb.ityp + 1, nb.jtyp + 1,
                                      nb.par[1] / ecnv, nb.par[0],
                                      nb.par[2], nb.par[3], nb.name + nb.comment))
                        for nb in self.vdw_drude:
                            fp.write('pair_coeff %4d %4d %12.6f %12.6f %8.4f %7.3f  ' \
                                     '# %s\n' % \
                                     (nb.ityp + 1, nb.jtyp + 1,
                                      0, 0, nb.par[2], nb.par[3], nb.name + nb.comment))

            if self.is_drude:
                f.write('group ATOMS type')
                for att in self.attype:
                    f.write(' %i' % (att.ityp + 1))
                f.write('\ngroup CORES type')
                for att in self.attype_drude:
                    f.write(' %i' % (att.ityp + 1))
                f.write('\ngroup DRUDES type')
                for att in self.attype_drude:
                    f.write(' %i' % (att.ityp_drude + 1))
                f.write('\nfix DRUDE all drude ' + \
                    ' '.join(['C' if att.drude else 'N' for att in self.attype]) + \
                    ' D' * len(self.attype_drude))
                f.write('\n\n')

            f.write('# thermo_style custom step press pe evdwl ecoul elong emol\n')
            f.write('# thermo 10\n')
            f.write('# minimize 1.0e-4 1.0e-6 1000 1000\n')
            f.write('# write_data data.em.lmp\n')
            f.write('# reset_timestep 0\n\n')
            
            shakebd = shakean = False
            for bdt in self.bdtype:
                if bdt.pot == 'cons':
                    shakebd = True
            for ant in self.antype:
                if ant.pot == 'cons':
                    shakean = True
            if shakebd or shakean:
                f.write('fix SHAKE %s shake 0.0001 20 0' % \
                        ('ATOMS' if self.is_drude else 'all'))
                if shakebd:
                    f.write(' b')
                    for bdt in self.bdtype:
                        if bdt.pot == 'cons':
                            f.write(' {0:d}'.format(bdt.ityp + 1))
                if shakean:
                    f.write(' a')
                    for ant in self.antype:
                        if ant.pot == 'cons':
                            f.write(' {0:d}'.format(ant.ityp + 1))
                f.write('\n')
            f.write('fix ICECUBE all momentum 100 linear 1 1 1\n\n')

            if units == 'r':
                f.write('timestep 1.0\n\n')
            elif units == 'm':
                f.write('timestep 0.001\n\n')

            f.write('variable TK equal 300.0\n')
            f.write('variable PBAR equal 1.0\n')
            f.write('variable elec equal ecoul+elong\n\n')

            if self.is_drude:
                f.write('velocity ATOMS create ${TK} 12345\n')
                f.write('velocity DRUDES create 1 23456\n\n')

                f.write('comm_modify vel yes\n')
                f.write('compute TDRUDE all temp/drude\n\n')
                
                f.write('fix TSTAT all langevin/drude ${TK} 100 12345 1 20 23456\n')
                f.write('fix NPH all nph iso ${PBAR} ${PBAR} 1000\n\n')
                
                f.write('# compute TATOM ATOMS temp\n')
                f.write('# fix DTDIR all drude/transform/direct\n')
                f.write('# fix TSTAT ATOMS npt temp ${TK} ${TK} 100 iso ${PBAR} ${PBAR} 1000\n')
                f.write('# fix_modify TSTAT temp TATOM press thermo_press\n')
                f.write('# fix TSTDR DRUDES nvt temp 1 1 20\n')
                f.write('# fix DTINV all drude/transform/inverse\n\n')

                f.write('thermo_style custom step cpu etotal ke pe '
                        'evdwl v_elec c_TDRUDE[1] press vol density '
                        'c_TDRUDE[2]\n')
            else:
                f.write('velocity all create ${TK} 12345\n\n')

                f.write('fix TPSTAT all npt temp ${TK} ${TK} 100 '
                        'iso ${PBAR} ${PBAR} 1000\n\n')

                f.write('thermo_style custom step cpu etotal ke pe '
                        'evdwl v_elec temp press vol density\n')
            f.write('thermo 100\n\n')

            f.write('dump TRAJ all custom 10000 dump.lammpstrj '
                    'id mol type element q x y z ix iy iz\n')
            f.write('dump_modify TRAJ sort id element %s %s\n' %(
                    ' '.join([att.symbol for att in self.attype]),
                    ' '.join(['D'] * len(self.attype_drude))))
            f.write('dump XTC all xtc 1000 dump.xtc\n')
            f.write('dump_modify XTC unwrap yes\n\n')

            f.write('variable t equal time\n')
            f.write('compute MSD all msd com yes\n')
            f.write('variable msd equal c_MSD[4]\n')
            f.write('fix PRMSD all print 2000 "${t} ${msd}" file msd.lammps '\
                    'screen no\n\n')

            f.write('variable vinst equal vol\n')
            f.write('fix VAVG all ave/time 10 1000 50000 v_vinst\n\n')

            f.write('# restart 10000 restart1.lmp restart2.lmp\n\n')
            
            f.write('run 50000\n\n')

            f.write('variable lscale equal (f_VAVG/v_vinst)^(1.0/3.0)\n')
            f.write('print "scaling coordinates by ${lscale}"\n')
            f.write('change_box all x scale ${lscale} y scale ${lscale} '\
                    'z scale ${lscale} remap\n\n')

            f.write('unfix VAVG\n')
            f.write('unfix TPSTAT\n')
            f.write('fix TSTAT all nvt temp ${TK} ${TK} 100\n\n')

            f.write('run 10000\n\n')

            f.write('write_data data.eq.lmp\n')

        with open('data.lmp', 'w') as f:
            f.write("created by fftool\n\n")
            f.write("{0:d} atoms\n".format(natom + ndrude))
            if nbond:
                f.write("{0:d} bonds\n".format(nbond + ndrude))
            if nangle:
                f.write("{0:d} angles\n".format(nangle))
            if ndihed:
                f.write("{0:d} dihedrals\n".format(ndihed))
            # f.write('\n')

            f.write("{0:d} atom types\n".format(len(self.attype)+len(self.attype_drude)))
            if nbond:
                f.write("{0:d} bond types\n".format(len(self.bdtype)+len(self.attype_drude)))
            if nangle:
                f.write("{0:d} angle types\n".format(len(self.antype)))
            if ndihed:
                ndht = len(self.dhtype)     # needed later
                f.write("{0:d} dihedral types\n".format(ndht +
                                                         len(self.ditype)))

            if self.box.center:
                f.write("{0:f} {1:f} xlo xhi\n".format(-self.box.lx / 2.0,
                                                        self.box.lx / 2.0))
                f.write("{0:f} {1:f} ylo yhi\n".format(-self.box.ly / 2.0,
                                                        self.box.ly / 2.0))
                f.write("{0:f} {1:f} zlo zhi\n".format(-self.box.lz / 2.0,
                                                        self.box.lz / 2.0))
            else:
                f.write("{0:f} {1:f} xlo xhi\n".format(0.0, self.box.lx))
                f.write("{0:f} {1:f} ylo yhi\n".format(0.0, self.box.ly))
                f.write("{0:f} {1:f} zlo zhi\n".format(0.0, self.box.lz))
            if self.box.triclinic:
                f.write("{0:f} {1:f} {2:f} xy xz yz\n".format(
                    self.box.xy, self.box.xz, self.box.yz))

            f.write('\nMasses\n\n')
            if not self.is_drude:
                for att in self.attype:
                   f.write("{0:4d} {1:8.3f}  # {2}\n".format(
                        att.ityp + 1, att.m, att.name))
            else:
                for att in self.attype:
                    f.write("{0:4d} {1:8.3f}  # {2}\n".format(
                        att.ityp + 1, att.m - att.md,
                        att.name + ' DC' if att.drude else att.name))

                for att in self.attype_drude:
                    f.write("{0:4d} {1:8.3f}  # {2}\n".format(
                        att.ityp_drude + 1, att.md, att.name + ' DP'))

            if nbond or self.is_drude:
                f.write('\nBond Coeffs\n\n')
                for bdt in self.bdtype:
                    f.write("{0:4d} {1:12.6f} {2:12.6f}  # {3}\n".format(
                             bdt.ityp + 1, bdt.par[1] / (2.0 * ecnv),
                             bdt.par[0], bdt.name))

                for att in self.attype_drude:
                    f.write("{0:4d} {1:12.6f} {2:12.6f}  # {3}\n".format(
                            att.ibtyp_drude + 1, 500.0, 0.0, att.name + ' DC-DP'))

            if nangle:
                f.write('\nAngle Coeffs\n\n')
                for ant in self.antype:
                    f.write("{0:4d} {1:12.6f} {2:12.6f}  # {3}\n".format(
                             ant.ityp + 1, ant.par[1] / (2.0 * ecnv),
                             ant.par[0], ant.name))

            if ndihed:
                f.write('\nDihedral Coeffs\n\n')
                for dht in self.dhtype:
                    f.write("{0:4d} {1:12.6f} {2:12.6f} {3:12.6f} {4:12.6f}  "\
                             "# {5}\n".format(dht.ityp + 1,
                              dht.par[0] / ecnv, dht.par[1] / ecnv,
                              dht.par[2] / ecnv, dht.par[3] / ecnv, dht.name))
                for dit in self.ditype:
                    f.write("{0:4d} {1:12.6f} {2:12.6f} {3:12.6f} {4:12.6f}  "\
                             "# {5}\n".format(ndht + dit.ityp + 1,
                              dit.par[0] / ecnv, dit.par[1] / ecnv,
                              dit.par[2] / ecnv, dit.par[3] / ecnv, dit.name))

            f.write('\nAtoms\n\n')
            i = nmol = shift= 0
            for sp in self.spec:
                for im in range(sp.nmol):
                    for at in sp.atom:
                        x, y, z = self.x[i - shift], self.y[i - shift], self.z[i - shift]
                        f.write("{0:7d} {1:7d} {2:4d} {3:10.6f} "
                                "{4:13.6e} {5:13.6e} {6:13.6e}  # {7} {8}{9}\n".format(
                                i + 1, nmol + 1, at.ityp + 1, at.q - at.qd,
                                x, y, z, at.name, sp.name, ' DC' if at.drude else ''))
                        i += 1
                        if at.drude:
                            att = next(filter(lambda x: x.name == at.name, self.attype))
                            f.write("{0:7d} {1:7d} {2:4d} {3:10.6f} "
                                    "{4:13.6e} {5:13.6e} {6:13.6e}  # {7} {8}{9}\n".format(
                                    i + 1, nmol + 1, att.ityp_drude + 1, at.qd,
                                    x + 0.1 * (random.random() - 0.5),
                                    y + 0.1 * (random.random() - 0.5),
                                    z + 0.1 * (random.random() - 0.5),
                                    at.name, sp.name, ' DP' if at.drude else ''))
                            i += 1
                            shift += 1
                    nmol += 1

            if nbond:
                f.write('\nBonds\n\n')
                i = shift = 1
                for sp in self.spec:
                    for im in range(sp.nmol):
                        for bd in sp.bond:
                            f.write("{0:7d} {1:4d} {2:7d} {3:7d}  # {4}\n".format(
                                    i, bd.ityp + 1,
                                    sp.get_aid_w_drude(bd.i) + shift,
                                    sp.get_aid_w_drude(bd.j) + shift, bd.name))
                            i += 1

                        for ii, at in enumerate(sp.atom):
                            if not at.drude:
                                continue
                            att = next(filter(lambda x: x.name == at.name, self.attype))
                            f.write("{0:7d} {1:4d} {2:7d} {3:7d}  # {4}\n".format(
                                    i, att.ibtyp_drude + 1,
                                    sp.get_aid_w_drude(ii) + shift,
                                    sp.get_aid_w_drude(ii) + 1 + shift, at.name + ' DC-DP'))
                            i += 1

                        shift += sp.n_atom + sp.n_drude

            if nangle:
                f.write('\nAngles\n\n')
                i = shift = 1
                for sp in self.spec:
                    for im in range(sp.nmol):
                        for an in sp.angle:
                            f.write("{0:7d} {1:4d} {2:7d} {3:7d} {4:7d}  # {5}\n".format(
                                    i, an.ityp + 1,
                                    sp.get_aid_w_drude(an.i) + shift,
                                    sp.get_aid_w_drude(an.j) + shift,
                                    sp.get_aid_w_drude(an.k) + shift, an.name))
                            i += 1
                        shift += sp.n_atom + sp.n_drude

            if ndihed:
                f.write('\nDihedrals\n\n')
                i = shift = 1
                for sp in self.spec:
                    for im in range(sp.nmol):
                        for dh in sp.dihed:
                            f.write("{0:7d} {1:4d} {2:7d} {3:7d} {4:7d} {5:7d}  # {6}\n".format(
                                   i, dh.ityp + 1,
                                   sp.get_aid_w_drude(dh.i) + shift,
                                   sp.get_aid_w_drude(dh.j) + shift,
                                   sp.get_aid_w_drude(dh.k) + shift,
                                   sp.get_aid_w_drude(dh.l) + shift, dh.name))
                            i += 1
                        for di in sp.dimpr:
                            f.write("{0:7d} {1:4d} {2:7d} {3:7d} {4:7d} {5:7d}  # {6}\n".format(
                                   i, ndht + di.ityp + 1,
                                   sp.get_aid_w_drude(di.i) + shift,
                                   sp.get_aid_w_drude(di.j) + shift,
                                   sp.get_aid_w_drude(di.k) + shift,
                                   sp.get_aid_w_drude(di.l) + shift, di.name))
                            i += 1
                        shift += sp.n_atom + sp.n_drude
                    
            # f.write('\n')

    def writegmx(self):
        self.writepdb()

        with open('field.top', 'w') as f:
            f.write('; created by fftool\n\n')
            
            f.write('[ defaults ]\n')
            if self.mix == 'g':
                combrule = 3
            else:
                combrule = 2
            f.write('; nbfunc   comb-rule   gen-pairs   fudgeLJ fudgeQQ\n')
            f.write('  1        {0:1d}           yes         0.5     0.5\n\n'\
                    .format(combrule))
            
            f.write('[ atomtypes ]\n')
            f.write('; name  at.nr     mass   charge  ptype  sigma        epsilon\n')
            for att in self.attype:
                f.write('{0:4s}       {1:2d} {2:8.4f} {3:8.4f}      A '\
                        '{4:12.5e} {5:12.5e}\n'.format(att.name,
                        atomic_number(att.name),
                        att.m, att.q, att.par[0]/10., att.par[1]))
            
            if self.is_drude:
                f.write('{0:4s}       {1:2d} {2:8.4f} {3:8.4f}      S ' \
                        '{4:12.5e} {5:12.5e}\n'.format('D', 0, 0, 0, 0, 0))
            f.write('\n')

            if self.allpairs:
                f.write('[ nonbond_params ]\n')
                f.write(';  i       j   func     sigma     epsilon\n')
                for nb in self.vdw:
                    f.write('%5s  %5s  %3i  %12.5e  %12.5e ;%s\n' % (
                        nb.i, nb.j, 1, nb.par[0]/10., nb.par[1], nb.comment))
            f.write('\n')

            for sp in self.spec:
                f.write('[ moleculetype ]\n')
                f.write('; name       nrexcl\n')
                f.write('{0:16s}  {1:1d}\n\n'.format(sp.name, 3))

                f.write('[ atoms ]\n')
                f.write(';  nr   type  resnr  residu   atom   cgnr    charge\n')
                aid_drudes = {}
                i = 1
                for at in sp.atom:
                    f.write('{0:5d}  {1:5s}  {2:5d}  {3:5s}    {4:5s}  {5:4d}  {6:10.6f}\n' \
                            .format(i, at.name, 1, sp.name[0:3], at.symbol, i, at.q-at.qd))
                    i += 1
                    if at.drude:
                        aid_drudes[i-1] = at
                        f.write('{0:5d}  {1:5s}  {2:5d}  {3:5s}    {4:5s}  {5:4d}  {6:10.6f}\n' \
                                .format(i, 'D', 1, sp.name[0:3], 'D', i, at.qd))
                        i += 1

                f.write('\n')

                pairs12 = []
                pairs13 = []
                pairs14 = []
                drude_pairs12 = []
                drude_pairs13 = []
                drude_pairs14 = []
                ids_drude = list(aid_drudes.keys())
                for bd in sp.bond_topol:
                    i, j =  sp.get_aid_w_drude(bd.i) + 1, sp.get_aid_w_drude(bd.j) + 1
                    pair = list(sorted([i, j]))
                    pairs12.append(pair)

                    if not (i in ids_drude and j in ids_drude):
                        continue
                    drude_pairs12.append(pair)
                for an in sp.angle_topol:
                    i_gmx, j_gmx, k_gmx = sp.get_aid_w_drude(an.i) + 1,\
                                          sp.get_aid_w_drude(an.j) + 1,\
                                          sp.get_aid_w_drude(an.k) + 1
                    for i, j in [[i_gmx, j_gmx], [i_gmx, k_gmx], [j_gmx, k_gmx]]:
                        pair = list(sorted([i, j]))
                        for p in pairs12:  # remove duplicates
                            if (i == p[0] and j == p[1]) or (i == p[1] and j == p[0]):
                                break
                        else:
                            pairs13.append(pair)

                        if not (i in ids_drude and j in ids_drude):
                            continue
                        for p in drude_pairs12:     # remove duplicates
                            if (i == p[0] and j == p[1]) or (i == p[1] and j == p[0]):
                                break
                        else:
                            drude_pairs13.append(pair)
                for di in sp.dihed_topol:
                    i_gmx, j_gmx, k_gmx, l_gmx = sp.get_aid_w_drude(di.i) + 1,\
                                                 sp.get_aid_w_drude(di.j) + 1,\
                                                 sp.get_aid_w_drude(di.k)+1,\
                                                 sp.get_aid_w_drude(di.l)+1
                    for i, j in [[i_gmx, j_gmx], [i_gmx, k_gmx], [i_gmx, l_gmx],
                                 [j_gmx, k_gmx], [j_gmx, l_gmx], [k_gmx, l_gmx]]:
                        pair = list(sorted([i, j]))
                        for p in pairs12 + pairs13:     # remove duplicates
                            if (i == p[0] and j == p[1]) or (i == p[1] and j == p[0]):
                                break
                        else:
                            pairs14.append(pair)

                        if not (i in ids_drude and j in ids_drude):
                            continue
                        for p in drude_pairs12 + drude_pairs13:     # remove duplicates
                            if (i == p[0] and j == p[1]) or (i == p[1] and j == p[0]):
                                break
                        else:
                            drude_pairs14.append(pair)
                drude_pairs12.sort(key=lambda x: [x[0], x[1]])
                drude_pairs13.sort(key=lambda x: [x[0], x[1]])
                drude_pairs14.sort(key=lambda x: [x[0], x[1]])

                if self.is_drude:
                    f.write('[ polarization ]\n')
                    f.write(';  ai    aj   func    alpha     delta     khyp\n')
                    for i, at in enumerate(sp.atom):
                        if at.drude:
                            f.write('%5d %5d   %4d  %9.6f  %7.4f  %9.4e\n' %(
                                sp.get_aid_w_drude(i) + 1, sp.get_aid_w_drude(i) + 2,
                                2, at.alpha / 1000, 0.02, 16.768e8))
                    f.write('\n')

                    f.write('[ thole_polarization ]\n')
                    f.write(';  ai    aj    ak    al   func   thole   alpha1   alpha2\n')
                    for i, j in drude_pairs12 + drude_pairs13:
                        at1 = aid_drudes[i]
                        at2 = aid_drudes[j]
                        f.write('{0:5d} {1:5d} {2:5d}  {3:5d}   {4:5d}   {5:9.5f}  {6:9.6f} {7:9.6f}\n'\
                                .format(i, i+1, j, j+1, 1, (at1.thole + at2.thole)/2,
                                 at1.alpha / 1000, at2.alpha / 1000))
                    f.write('\n')

                f.write('[ bonds ]\n')
                f.write(';  ai    aj   func    b0        kb\n')
                for bd in sp.bond:
                    if bd.pot != 'cons':
                        f.write('{0:5d} {1:5d}     {2:2d}  {3:9.5f}  {4:9.1f}\n'.format(
                                sp.get_aid_w_drude(bd.i) + 1, sp.get_aid_w_drude(bd.j) + 1,
                                1, bd.par[0] / 10.0, bd.par[1] * 100.0))
                f.write('\n')

                f.write('[ constraints ]\n')
                f.write(';  ai    aj   func    b0\n')
                for bd in sp.bond:
                    if bd.pot == 'cons':
                        f.write('{0:5d} {1:5d}     {2:2d}  {3:9.5f}\n'.format(
                                sp.get_aid_w_drude(bd.i) + 1, sp.get_aid_w_drude(bd.j) + 1,
                                1, bd.par[0]/10.0))
                f.write('\n')

                if self.is_drude:
                    f.write('[ exclusions ]\n')
                    f.write(';  ai    aj    ...\n')
                    exclusions = {} # {idrude: [j, jdrude, k, kdrude, ...]}
                    for i, j in pairs12 + pairs13  + pairs14:
                        if i in ids_drude:
                            idrude = i + 1
                            if idrude not in exclusions:
                                exclusions[idrude] = []
                            exclusions[idrude].append(j)
                        if j in ids_drude:
                            jdrude = j+ 1
                            if jdrude not in exclusions:
                                exclusions[jdrude] = []
                            exclusions[jdrude].append(i)
                        if i in ids_drude and j in ids_drude:
                            exclusions[idrude].append(jdrude)
                    for i in sorted(exclusions.keys()):
                        f.write('%5d' % i)
                        for j in exclusions[i]:
                            f.write(' %5d' %j)
                        f.write('\n')
                    f.write('\n')

                f.write('[ pairs ]\n')
                f.write(';   ai   aj   func\n')
                pairs = []
                for i, j in pairs14:
                    pairs.append([i, j])
                    if self.is_drude:
                        if i in ids_drude:
                            idrude = i + 1
                            pairs.append([idrude, j])
                        if j in ids_drude:
                            jdrude = j + 1
                            pairs.append([i, jdrude])
                        if i in ids_drude and j in ids_drude:
                            pairs.append([idrude, jdrude])

                for i, j in pairs:
                    f.write('%5d %5d    %2d\n' %(i, j , 1))
                f.write('\n')

                f.write('[ angles ]\n')
                f.write(';  ai    aj    ak   func    th0        cth\n')
                for an in sp.angle:
                    f.write('{0:5d} {1:5d} {2:5d}     {3:2d}  {4:9.3f}  {5:9.3f}\n'.format(
                            sp.get_aid_w_drude(an.i) + 1, sp.get_aid_w_drude(an.j) + 1,
                            sp.get_aid_w_drude(an.k) + 1, 1, an.par[0], an.par[1]))
                f.write('\n')

                f.write('[ dihedrals ]\n')
                f.write(';  ai    aj    ak    al   func    coefficients\n')
                for dh in sp.dihed:
                    f.write('{0:5d} {1:5d} {2:5d} {3:5d}     {4:2d}  {5:9.5f} {6:9.5f} {7:9.5f} {8:9.5f}\n'\
                             .format(sp.get_aid_w_drude(dh.i) + 1, sp.get_aid_w_drude(dh.j) + 1,
                                     sp.get_aid_w_drude(dh.k) + 1, sp.get_aid_w_drude(dh.l) + 1,
                                     5, dh.par[0], dh.par[1], dh.par[2], dh.par[3]))
                for di in sp.dimpr:
                    f.write('{0:5d} {1:5d} {2:5d} {3:5d}     {4:2d}  {5:9.5f} {6:9.5f} {7:9.5f} {8:9.5f}\n'\
                             .format(sp.get_aid_w_drude(di.i) + 1, sp.get_aid_w_drude(di.j) + 1,
                                     sp.get_aid_w_drude(di.k) + 1, sp.get_aid_w_drude(di.l) + 1,
                                     5, di.par[0], di.par[1], di.par[2], di.par[3]))
                f.write('\n')

            f.write('[ system ]\n')
            f.write('simbox\n\n')

            f.write('[ molecules ]\n')
            for sp in self.spec:
                f.write('{0:16s} {1:5d}\n'.format(sp.name, sp.nmol))

        with open('run.mdp', 'w') as f:
            f.write('integrator            = sd; md\n')
            f.write('dt                    = 0.001\n')
            f.write('nsteps                = 10000\n\n')
            
            f.write('nstlog                = 1000\n')
            f.write('nstenergy             = 100\n')
            f.write('nstxout               = 10000\n')
            f.write('nstvout               = 10000\n')
            f.write('nstxout-compressed    = 1000\n\n')

            f.write('cutoff-scheme         = Verlet\n')
            f.write('pbc                   = xyz\n\n')
            f.write('rlist                 = 1.2\n')

            f.write('coulombtype           = PME\n')
            f.write('rcoulomb              = 1.2\n')
            f.write('ewald-rtol            = 1.0e-5\n')
            f.write('vdwtype               = Cut-off\n')
            f.write('rvdw                  = 1.2\n')
            f.write('DispCorr              = EnerPres\n\n')

            f.write('tcoupl                = no; V-rescale\n')
            f.write('tc-grps               = System\n')
            f.write('tau-t                 = 1.0; 0.1; ps\n')
            f.write('ref-t                 = 300.0\n\n')

            f.write('pcoupl                = Berendsen; Parrinello-Rahman\n')
            f.write('pcoupltype            = isotropic\n')
            f.write('tau-p                 = 0.5; 1.0; ps\n')
            f.write('ref-p                 = 1.0\n')
            f.write('compressibility       = 4.5e-5\n\n')

            f.write('gen-vel               = yes\n')
            f.write('gen-temp              = 300\n\n')

            f.write('constraints           = h-bonds\n')
            f.write('constraint-algorithm  = LINCS\n')
            f.write('continuation          = no\n\n')
            
    def writedlp(self, cos4 = False):
        with open('FIELD', 'w') as f:
            f.write('created by fftool\n')
            f.write('units kJ\n\n')
            
            f.write("molecular types {0:d}\n".format(len(self.spec)))
            for sp in self.spec:
                f.write("{0}\n".format(sp.name))
                f.write("nummols {0:d}\n".format(sp.nmol))
                f.write("atoms {0:d}\n".format(len(sp.atom)))
                for at in sp.atom:
                    f.write("{0:5s} {1:8.4f} {2:6.3f} 1  # {3}\n".format(
                            at.name, at.m, at.q, at.type))
                ncons = 0
                for bd in sp.bond: 
                    if bd.pot == 'cons':
                        ncons += 1
                f.write("constraints {0:d}\n".format(ncons))
                for bd in sp.bond:
                    if bd.pot == 'cons':
                        f.write("{0:4d} {1:4d} {2:6.3f}  # {3}\n".format(
                                bd.i + 1, bd.j + 1, bd.par[0], bd.name))
                f.write("bonds {0:d}\n".format(len(sp.bond) - ncons))
                for bd in sp.bond:
                    if bd.pot != 'cons':
                        f.write("{0:4s} {1:4d} {2:4d} {3:7.1f} {4:6.3f}  "
                                "# {5}\n".format(bd.pot, bd.i + 1, bd.j + 1,
                                 bd.par[1], bd.par[0], bd.name))
                f.write("angles {0:d}\n".format(len(sp.angle)))
                for an in sp.angle:
                    f.write("{0:4s} {1:4d} {2:4d} {3:4d} {4:7.2f} {5:7.2f}  "
                            "# {6}\n".format(an.pot, an.i + 1, an.j + 1,
                            an.k + 1, an.par[1], an.par[0], an.name))
                f.write("dihedrals {0:d}\n".format(len(sp.dihed) +
                                                   len(sp.dimpr)))
                for dh in sp.dihed:
                    if cos4:
                        pot = 'cos4'
                        f.write("{0:4s} {1:4d} {2:4d} {3:4d} {4:4d} "
                                "{5:9.4f} {6:9.4f} {7:9.4f} {8:9.4f} "
                                "{9:6.3f} {10:6.3f}  # {11}\n".format(pot,
                                 dh.i + 1, dh.j + 1, dh.k + 1, dh.l + 1,
                                 dh.par[0], dh.par[1], dh.par[2], dh.par[3],
                                 0.5, 0.5, dh.name))
                    else:
                        pot = 'cos3'
                        f.write("{0:4s} {1:4d} {2:4d} {3:4d} {4:4d} "
                                "{5:9.4f} {6:9.4f} {7:9.4f} "
                                "{8:6.3f} {9:6.3f}  # {10}\n".format(pot,
                                dh.i + 1, dh.j + 1, dh.k + 1, dh.l + 1,
                                dh.par[0], dh.par[1], dh.par[2],
                                0.5, 0.5, dh.name))
                for di in sp.dimpr:
                    if cos4:
                        pot = 'cos4'
                        f.write("{0:4s} {1:4d} {2:4d} {3:4d} {4:4d} "
                                "{5:9.4f} {6:9.4f} {7:9.4f} {8:9.4f} "
                                "{9:6.3f} {10:6.3f}  # {11}\n".format(pot,
                                di.i + 1, di.j + 1, di.k + 1, di.l + 1,
                                di.par[0], di.par[1], di.par[2], di.par[3],
                                0.5, 0.5, di.name))
                    else:
                        pot = 'cos3'
                        f.write("{0:4s} {1:4d} {2:4d} {3:4d} {4:4d} "
                                "{5:9.4f} {6:9.4f} {7:9.4f} "
                                "{8:6.3f} {9:6.3f}  # {10}\n".format(pot,
                                di.i + 1, di.j + 1, di.k + 1, di.l + 1,
                                di.par[0], di.par[1], di.par[2],
                                0.5, 0.5, di.name))
                f.write("finish\n")

            f.write("vdw {0:d}\n".format(len(self.vdw)))
            for nb in self.vdw:
                if nb.pot == 'lj':
                    f.write("{0:5s} {1:5s} {2:>4s} {3:10.6f} "
                            "{4:8.4f}\n".format(nb.i, nb.j, nb.pot,
                            nb.par[1], nb.par[0]))
            f.write("close\n")

        with open('CONFIG', 'w') as f:
            f.write("created by fftool\n")
            if self.box.triclinic:
                imcon = 3
            elif self.box.a == self.box.b and self.box.b == self.box.c:
                imcon = 1
            else:
                imcon = 2
            f.write(" {0:9d} {1:9d} {2:9d}\n".format(0, imcon, self.natom))
            f.write(" {0:19.9f} {1:19.9f} {2:19.9f}\n".format(self.box.lx,
                    0.0, 0.0))
            f.write(" {0:19.9f} {1:19.9f} {2:19.9f}\n".format(self.box.xy,
                    self.box.ly, 0.0))
            f.write(" {0:19.9f} {1:19.9f} {2:19.9f}\n".format(self.box.xz,
                    self.box.yz, self.box.lz))

            i = 0
            for sp in self.spec:
                for im in range(sp.nmol):
                    for at in sp.atom:
                        f.write("{0:8s} {1:9d}\n".format(at.name, i + 1))
                        f.write(" {0:19.9f} {1:19.9f} {2:19.9f}\n"\
                            .format(self.x[i], self.y[i], self.z[i]))
                        i += 1

    def writenamd(self):
        self.writepdb()

        natom = ndrude = nbond = nangle = ndihed = 0
        for sp in self.spec:
            natom += sp.nmol * len(sp.atom)
            nbond += sp.nmol * len(sp.bond)
            nangle += sp.nmol * len(sp.angle)
            ndihed += sp.nmol * (len(sp.dihed) + len(sp.dimpr))
            
            if self.is_drude:
                ndrude += sp.nmol * sp.n_drude

        with open('topol.psf', 'w') as f:
            f.write("PSF%s\n\n" %(' DRUDE' if self.is_drude else ''))
            f.write("       1 !NTITLE\n")
            f.write(" REMARKS Created by fftool\n\n")
            
            f.write(" {0:7d} !NATOM\n".format(natom + ndrude))
            i = nmol = 0
            for sp in self.spec:
                for im in range(sp.nmol):
                    for ii, at in enumerate(sp.atom):
                        f.write(" {0:7d} S    {1:<4d} {2:>4s} {3:4s} {4:4s} "
                                "{5:10.6f} {6:13.4f} {7:11d} {8:13.4f} {9:13.4f}\n".format(
                                i + 1, nmol + 1, sp.name[:3], at.symbol, at.name,
                                at.q - at.qd, at.m - at.md, 0, -at.alpha, at.thole / 2))
                        i += 1
                        if at.drude:
                            f.write(" {0:7d} S    {1:<4d} {2:>4s} {3:4s} {4:4s} "
                                    "{5:10.6f} {6:13.4f} {7:11d} {8:13.4f} {9:13.4f}\n".format(
                                    i + 1, nmol + 1, sp.name[:3], 'D', 'D',
                                    at.qd, at.md, 0, 0, 0))
                            i += 1
                    nmol += 1

            f.write("\n {0:7d} !NBOND: bonds\n".format(nbond + ndrude))
            i = shift = 1
            for sp in self.spec:
                for im in range(sp.nmol):
                    for ii, at in enumerate(sp.atom):
                        if at.drude:
                            f.write(" {0:7d} {1:7d}".format(sp.get_aid_w_drude(ii) + shift,
                                                            sp.get_aid_w_drude(ii) + 1 + shift))
                            if (i % 4) == 0:
                                f.write('\n')
                            i += 1

                    for bd in sp.bond:
                        f.write(" {0:7d} {1:7d}".format(sp.get_aid_w_drude(bd.j) + shift,
                                                        sp.get_aid_w_drude(bd.i) + shift))
                        if (i % 4) == 0:
                            f.write('\n')
                        i += 1
                    shift += sp.n_atom + sp.n_drude

            if ((i - 1) % 4) != 0:
                f.write('\n')

            f.write("\n {0:7d} !NTHETA: angles\n".format(nangle))
            i = shift = 1
            for sp in self.spec:
                for im in range(sp.nmol):
                    for an in sp.angle:
                        f.write(" {0:7d} {1:7d} {2:7d}".format(
                                sp.get_aid_w_drude(an.i) + shift,
                                sp.get_aid_w_drude(an.j) + shift,
                                sp.get_aid_w_drude(an.k) + shift))
                        if (i % 3) == 0:
                            f.write('\n')
                        i += 1
                    shift += sp.n_atom + sp.n_drude

            if ((i - 1) % 3) != 0:
                f.write('\n')

            f.write("\n {0:7d} !NPHI: dihedrals\n".format(ndihed))
            i = shift = 1
            for sp in self.spec:
                for im in range(sp.nmol):
                    for dh in sp.dihed:
                        f.write(" {0:7d} {1:7d} {2:7d} {3:7d}".format(
                                sp.get_aid_w_drude(dh.i) + shift,
                                sp.get_aid_w_drude(dh.j) + shift,
                                sp.get_aid_w_drude(dh.k) + shift,
                                sp.get_aid_w_drude(dh.l) + shift))
                        if (i % 2) == 0:
                            f.write('\n')
                        i += 1
                    for di in sp.dimpr:
                        f.write(" {0:7d} {1:7d} {2:7d} {3:7d}".format(
                                sp.get_aid_w_drude(dh.i) + shift,
                                sp.get_aid_w_drude(dh.j) + shift,
                                sp.get_aid_w_drude(dh.k) + shift,
                                sp.get_aid_w_drude(dh.l) + shift))
                        if (i % 2) == 0:
                            f.write('\n')
                        i += 1
                    shift += sp.n_atom + sp.n_drude

            if ((i - 1) % 2) != 0:
                f.write('\n')

            f.write("\n %7d !NIMPHI: impropers\n" % 0)
            f.write("\n %7d !NDON: donors\n" % 0)
            f.write("\n %7d !NACC: acceptors\n" % 0)
            f.write("\n %7d !NNB\n\n" % 0) # one extra blank lines after NNB. No one knows why
            if self.is_drude:
                f.write("\n %7d !NUMANISO\n" % 0)

            f.write('\n')

        with open('ff.prm', 'w') as f:
            f.write('* CHARMM FORCE FIELD GENERATED BY fftool\n')
            f.write('*\n')
            ecnv = kCal

            f.write('\nATOMS\n')
            for att in self.attype:
                f.write("  MASS %5i %5s %12.6f\n" %(-1, att.name, att.m))
            if self.is_drude:
                f.write("  MASS %5i %5s %12.6f\n" %(-1, 'D', 0.4))


            f.write('\nBONDS\n')
            bond_unique = []
            for sp in self.spec:
                for bd in sp.bond:
                    name = [sp.atom[bd.i].name, sp.atom[bd.j].name]
                    if name in bond_unique or list(reversed(name)) in bond_unique:
                        continue
                    bond_unique.append(name)
                    f.write(" %5s %5s %12.6f %12.6f\n" %(
                        *name, bd.par[1] / (2.0 * ecnv), bd.par[0]))
            for att in self.attype_drude:
                f.write(" %5s %5s %12.6f %12.6f\n" %(att.name, 'D', 500, 0))

            f.write('\nANGLES\n')
            angle_unique = []
            for sp in self.spec:
                for an in sp.angle:
                    name = [sp.atom[an.i].name, sp.atom[an.j].name, sp.atom[an.k].name]
                    if name in angle_unique or list(reversed(name)) in angle_unique:
                        continue
                    angle_unique.append(name)
                    f.write(" %5s %5s %5s %12.6f %12.6f\n" %(
                            *name, an.par[1] / (2.0 * ecnv), an.par[0]))

            f.write('\nDIHEDRALS\n')
            dihed_unique = []
            for sp in self.spec:
                for dh in sp.dihed + sp.dimpr:
                    name = [sp.atom[dh.i].name, sp.atom[dh.j].name, sp.atom[dh.k].name, sp.atom[dh.l].name]
                    if name in dihed_unique or list(reversed(name)) in dihed_unique:
                        continue
                    dihed_unique.append(name)
                    if dh.par[0] != 0:
                        f.write(" %5s %5s %5s %5s %12.6f %8i %8i\n" %(
                                *name, dh.par[0] / (2.0 * ecnv), 1, 0))
                    if dh.par[1] != 0:
                        f.write(" %5s %5s %5s %5s %12.6f %8i %8i\n" %(
                                *name, dh.par[1] / (2.0 * ecnv), 2, 180))
                    if dh.par[2] != 0:
                        f.write(" %5s %5s %5s %5s %12.6f %8i %8i\n" %(
                                *name, dh.par[2] / (2.0 * ecnv), 3, 0))
                    if dh.par[0] == 0 and dh.par[1] == 0 and dh.par[2] == 0:
                        f.write(" %5s %5s %5s %5s %12.6f %8i %8i  ! %s\n" %(
                                *name, 0, 1, 0, 'no dihedral parameters'))

            f.write('\nNONBONDED\n')
            f.write('!VLJ = Eps,i,j[(Rmin,i,j/ri,j)**12 - 2(Rmin,i,j/ri,j)**6]\n'
                    '!epsilon: kcal/mole, Eps,i,j = sqrt(eps,i * eps,j)\n'
                    '!Rmin/2: A, Rmin,i,j = Rmin/2,i + Rmin/2,j\n'
                    '!atom    ignored      epsilon      Rmin/2     ignored     eps,1-4     Rmin/2,1-4\n')
            for att in self.attype:
                f.write(' %5s %12.6f %12.6f %12.6f %12.6f %12.6f %12.6f\n' %(
                        att.name, 0.0, -att.par[1] / ecnv, att.par[0] * 2**(1/6) / 2,
                        0.0, -att.par[1] / ecnv / 2, att.par[0] * 2**(1/6) / 2))
            if self.is_drude:
                f.write(' %5s %12.6f %12.6f %12.6f %12.6f %12.6f %12.6f\n' % (
                        'D', 0.0, 0, 0, 0.0, 0, 0))

            if self.allpairs:
                f.write('\nNBFIX\n')
                f.write('!atom1     atom2       Emin         Rmin       Emin,1-4    Rmin,1-4\n'
                        '!                   (kcal/mol)      (A)\n')
                for nb in self.vdw:
                    f.write(' %5s %5s %12.6f %12.6f %12.6f %12.6f  !%s\n' %(
                        nb.i, nb.j, -nb.par[1] / ecnv, nb.par[0] * 2**(1/6),
                        -nb.par[1] / ecnv / 2, nb.par[0] * 2**(1/6), nb.comment))

            f.write('\nEND\n')

        with open('run.inp', 'w') as f:
            f.write('set T 300\n'
                    'set P 1.0\n'
                    'timestep 1.0  # fs\n'
                    '# initial config\n'
                    'coordinates config.pdb\n'
                    'temperature $T\n'
                    'seed 12345\n'
                    'cellBasisVector1 %.2f 0 0\n'
                    'cellBasisVector2 0 %.2f 0\n'
                    'cellBasisVector3 0 0 %.2f\n'
                    '# output params\n'
                    'outputname out\n'
                    'binaryoutput no\n'
                    'outputEnergies 100\n'
                    'DCDfreq 1000\n'
                    'restartfreq 10000\n'
                    '# force field params\n'
                    'structure topol.psf\n'
                    'parameters ff.prm\n'
                    'paraTypeCharmm on\n'
                    'vdwGeometricSigma %s\n'
                    'LJcorrection yes\n'
                    'exclude scaled1-4\n'
                    '1-4scaling 0.5\n'
                    'switching off\n'
                    'cutoff 12.0\n'
                    'pairlistdist 14.0\n'
                    '# electrostatics\n'
                    'PME on\n'
                    'PMEGridSpacing 1\n'
                    'dielectric 1\n'
                    '# constraints\n'
                    'rigidBonds all\n'
                    'useSettle yes\n'
                    '# thermostat\n'
                    'COMmotion no\n'
                    'langevin on\n'
                    'langevinHydrogen no\n'
                    'langevinTemp $T\n'
                    'langevinDamping 1.0  # /ps  # set to 10.0 for drude model\n'
                    '#stochRescale on\n'
                    '#stochRescaleTemp $T\n'
                    '#stochRescalePeriod 0.1 # ps\n'
                    '# barostat\n'
                    'useGroupPressure yes\n'
                    'langevinPiston on\n'
                    'langevinPistonTarget $P\n'
                    'langevinPistonPeriod 1000  # fs\n'
                    'langevinPistonDecay 500  # fs\n'
                    'langevinPistonTemp $T\n'
                    '#berendsenPressure yes\n'
                    '#berendsenPressureTarget $P\n'
                    '#berendsenPressureCompressibility 4.5E-5\n'
                    '#berendsenPressureRelaxationTime 500  # fs\n'
                    '# run\n'
                    '#minimization on\n'
                    '#minimize 1000\n'
                    'run 10000\n'
                    % (self.box.a, self.box.b, self.box.c, 'yes' if self.mix == 'g' else 'no'))
            if self.is_drude:
                f.write('# drude\n'
                        'drude on\n'
                        'drudeTemp 1\n'
                        'drudeDamping 50.0  # /ps\n'
                        'drudeHardWall on\n'
                        'drudeBondLen 0.25  # A\n')

    def writepdb(self):
        with open('config.pdb', 'w') as f:
            f.write('TITLE     created by fftool\n')
            f.write('REMARK    SIMBOX\n')
            f.write('CRYST1{0:9.3f}{1:9.3f}{2:9.3f}{3:7.2f}{4:7.2f}{5:7.2f} ' \
                    '{6:11s}{7:4d}\n'.format(
                self.box.a, self.box.b, self.box.c,
                self.box.alpha, self.box.beta, self.box.gamma, 'P 1', 1))
            i = nmol = 0
            shift = 0
            for sp in self.spec:
                for im in range(sp.nmol):
                    for ii, at in enumerate(sp.atom):
                        line = 'ATOM  {0:5d} {1:4s} {2:3s}  {3:4d}    ' \
                               '{4:8.3f}{5:8.3f}{6:8.3f}  1.00  0.00' \
                               '          {7:2s}\n'.format(
                            i + 1, at.symbol, sp.name[:3], nmol + 1,
                            self.x[i-shift], self.y[i-shift], self.z[i-shift], at.symbol)
                        f.write(line)
                        i += 1
                        if at.drude:
                            line = 'ATOM  {0:5d} {1:4s} {2:3s}  {3:4d}    ' \
                                   '{4:8.3f}{5:8.3f}{6:8.3f}  1.00  0.00' \
                                   '          {7:2s}\n'.format(
                                i + 1, 'D',
                                sp.name[:3], nmol + 1,
                                self.x[i-1-shift] + 0.1 * (random.random() - 0.5),
                                self.y[i-1-shift] + 0.1 * (random.random() - 0.5),
                                self.z[i-1-shift] + 0.1 * (random.random() - 0.5),
                                at.symbol)
                            f.write(line)
                            i += 1
                            shift += 1
                    nmol += 1
            f.write("END\n")

# --------------------------------------


def main():
    parser = argparse.ArgumentParser(
        description = 'Force-field parameters and atomic coordinates for '\
        'molecules described in z-matrix, MDL mol, PDB or xyz formats. '\
        'Produces pack.inp file for use with Packmol to build simulation box. '\
        'Then rerun with option to create input files for MD simulation. '\
        'The name of a file with force field parameters can be supplied: '\
        'i) on a line at the end of the .zmat file, '\
        'ii) on the 3rd line of the .mol file, or on the 1st after the '\
        'molecule name, '\
        'iii) after the molecule name in a COMPND record in the .pdb file, '\
        'iv) on the 2nd line of the .xyz file after the molecule name.')
    parser.add_argument('-b', '--box', default = '', help = 'box length in A '\
                        '(cubic), for non-cubic boxes supply '
                        'a,b,c[,alpha,beta,gamma] default box '\
                        'is orthogonal (alpha = beta = gamma = 90.0)')
    parser.add_argument('-r', '--rho', type=float, default = 0.0,
                        help = 'density in mol/L')
    parser.add_argument('-c', '--center', action = 'store_true',
                        help = 'center box on origin')
    parser.add_argument('-t', '--tol', type=float, default = 2.5,
                        help = 'tolerance for Packmol (default: 2.5)')
    parser.add_argument('-x', '--mix', default = 'g',
                        help = '[a]rithmetic or [g]eometric sigma_ij '\
                        '(default: g)')
    parser.add_argument('-l', '--lammps', action = 'store_true',
                        help = 'save LAMMPS input files '\
                        '(needs simbox.xyz built using Packmol)')
    parser.add_argument('-a', '--allpairs', action = 'store_true', 
                        help = 'write all I J pairs to LAMMPS input files.')
    parser.add_argument('-u', '--units', default = 'r',
                        help = 'LAMMPS units [r]eal or [m]etal (default: r)')
    parser.add_argument('-p', '--pbc', default = '',
                        help = 'connect bonds across periodic boundaries in '\
                        'x, xy, xyz, etc. (default: none)')
    parser.add_argument('-g', '--gmx', action = 'store_true',
                        help = 'save GROMACS input files '\
                        '(needs simbox.xyz built using Packmol)')
    parser.add_argument('-n', '--namd', action = 'store_true',
                        help = 'save NAMD input files'
                        '(needs simbox.xyz built using Packmol)')
    parser.add_argument('-d', '--dlpoly', action = 'store_true',
                        help = 'save DLPOLY input files '\
                        '(needs simbox.xyz built using Packmol)')
    parser.add_argument('--drude', type=str,
                        help = 'drude parameters for exporting drude models. ' \
                        'Does not work for dlpoly. '\
                        'Be careful that the implementation of drude model '\
                        'in LAMMPS, GROMACS and NAMD are different')
    parser.add_argument('--scaleeps', type=str,
                        help = 'fragment files for scaling LJ epsilon. ' \
                        'Does not work for dlpoly')
    parser.add_argument('--scalesig', type=float, default=1,
                        help = 'sigma will be scaled ' \
                        'Does not work for dlpoly')
    parser.add_argument('--cos4', action = 'store_true',
                        help = 'use cos4 dihedrals in DLPOLY FIELD')
    parser.add_argument('infiles', nargs='+',
                        help = 'n1 infile1 [n2 infile2 ...], '\
                        'where n_i are the numbers of molecules defined in '\
                        'infile_i. Use extension .zmat, .mol, .pdb or .xyz')
    args = parser.parse_args()

    if len(args.infiles) == 1:
        nmols = [1]
        files = args.infiles
    else:
        nmols = args.infiles[::2]   # even elements are numbers of molecules
        files = args.infiles[1::2]  # odd elements are zmat files
    nmol = sum(int(n) for n in nmols)

    if args.box and args.rho != 0.0:
        print('supply density or box dimensions, not both')
        sys.exit(1)
    
    if args.box:
        tok = args.box.split(',')
        if len(tok) == 1:
            a = b = c = float(tok[0])
            alpha = beta = gamma = 90.0
        elif len(tok) == 3:
            a, b, c = [ float(t) for t in tok ]
            alpha = beta = gamma = 90.0
        elif len(tok) == 6:
            a = float(tok[0])
            b = float(tok[1])
            c = float(tok[2])
            alpha = float(tok[3])
            beta = float(tok[4])
            gamma = float(tok[5])
        else:
            print('wrong box dimensions and angles')
            sys.exit(1)
    elif args.rho != 0.0:
        a = b = c = math.pow(nmol / (args.rho * 6.022e+23 * 1.0e-27), 1./3.)
        alpha = beta = gamma = 90.0
    else:
        print('density or box dimensions need to be supplied')
        sys.exit(1)

    box = cell(a, b, c, alpha, beta, gamma, args.pbc, args.center)
    rho = nmol / (box.vol * 1.0e-27 * 6.022e+23)
    print('density {0:.3f} mol/L  volume {1:.1f} A^3'.format(rho, box.vol))

    if args.lammps or args.gmx or args.dlpoly or args.namd:
        connect = True
    else:
        connect = False

    print('molecule descriptions')
    spec = []
    i = 0
    for zfile in files:
        print('  ' + zfile)
        spec.append(mol(zfile, connect, box))
        spec[i].nmol = int(nmols[i])
        spec[i].writexyz()
        i += 1

    sim = system(spec, box, args.mix, args.drude, args.scaleeps, args.scalesig, args.allpairs)

    print('species                 nmol  bonds   charge   alpha')
    for sp in spec:
        print('  {0:20s} {1:5d}  {2:5s} {3:+8.4f} {4:8.4f}'.format(sp.name,
              sp.nmol, sp.topol, sp.charge(), sp.alpha))

    if not (args.lammps or args.gmx or args.dlpoly or args.namd):
        print('packmol file\n  pack.inp')
        sim.writepackmol('pack.inp', 'simbox.xyz', args.tol, args.tol / 2)
    else:
        sim.readcoords('simbox.xyz')

    if args.lammps:
        if args.units == 'r':
            print('lammps files units real')
        elif args.units == 'm':
            print('lammps files units metal')
        else:
            print('invalid units: choose [r]eal or [m]etal')
            sys.exit(1)
        print('  in.lmp\n  data.lmp')
        if (args.allpairs or args.scaleeps or args.scalesig != 1.0):
            print('  pair.lmp')
        sim.writelmp(args.units)
    if args.gmx:
        print('gromacs files\n  run.mdp\n  field.top\n  config.pdb')
        sim.writegmx()
    if args.dlpoly:
        print('dlpoly files\n  FIELD\n  CONFIG')
        sim.writedlp(args.cos4)       
    if args.namd:
        print('namd files\n  run.inp\n  topol.psf\n  ff.prm\n  config.pdb')
        sim.writenamd()

if __name__ == '__main__':
    main()

